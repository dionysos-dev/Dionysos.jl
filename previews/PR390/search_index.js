var documenterSearchIndex = {"docs":
[{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"../examples/Getting Started.jl\"","category":"page"},{"location":"generated/Getting Started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In this file we will visit the basic functionalities provided by Dionysos for the optimal control of complex systems. In summary, the topics covered are","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Grids and discretizations\nDynamical system declaration\nContinuous and discrete state image mapping\nPlotting","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"First, let us import a few packages that are necessary to run this example.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"using Dionysos\nusing StaticArrays\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The main package Dionysos provides most important data structures that we will need. Additionally  StaticArrays provides faster implementation of Arrays (which have static memory allocation), LinearAlgebra allows us to perform some additional operations.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"const DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst SY = DI.Symbolic","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Additionally, we will short the submodules accondingly","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"We use HyperRectangle to represent the boundary of the state space rectX and the input space rectU.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"rectX = UT.HyperRectangle(SVector(-2, -2), SVector(2, 2));\nrectU = UT.HyperRectangle(SVector(-5), SVector(5));\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"A discretization of the state space is declared using the GridFree structure, which requires the definition of a center x0 and a vector h of discretization steps in each direction.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"x0 = SVector(0.0, 0.0);\nh = SVector(1.0 / 5, 1.0 / 5);\nXgrid = DO.GridFree(x0, h);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Xgrid represents the state space grid and holds information of x0 and h, but is not a collection of cells. Indeed, a cell can be efficiently represented by a tuple of Int, for instance 'pos', with which the corresponding cartesian position can be computed by x0 + h .* pos or using functions to be shown. In Dionysos, a set of cells is called a Domain and the DomainList structure is used to represent this set. In the following, domainX is defined as an empty DomainList over the grid Xgrid and the add_set! method is responsible for adding a set of cells to the DomainList","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"domainX = DO.DomainList(Xgrid);\nDO.add_set!(domainX, rectX, DO.INNER)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In this last line of code, add_set! add all the cells of the grid Xgrid to the DomainList domainX that are contained in the HyperRectangle rectX Construction of the struct DomainList containing the feasible cells of the state-space. Note, we used DO.INNER to make sure to add cells entirely contained in the domain. If we would like to add also cells partially covered by a given HyperRectangle, DO.OUTER should be used instead.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Similarly, we define a discretization of the input-space on which the abstraction is based (origin u0 and input-space discretization h):","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"u0 = SVector(0.0);\nh = SVector(1.0 / 5);\nUgrid = DO.GridFree(u0, h);\ndomainU = DO.DomainList(Ugrid);\nDO.add_set!(domainU, rectU, DO.INNER);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Now we have to define our dynamical system. For the sake of simplicity, note that we consider a linear time-invariant dynamical system but the functions defining it allow the definition of a generic nonlinear and time-dependent system. We also define a step time tstep for discretizing the continuous-time dynamic. The parameters","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"tstep = 0.1;\nnsys = 10; # Runge-Kutta pre-scaling\n\nA = SMatrix{2, 2}(0.0, 1.0, -3.0, 1.0);\nB = SMatrix{2, 1}(0.0, 1.0);\n\nF_sys = let A = A\n    (x, u) -> A * x + B * u\nend;\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"We also need to define a growth-bound function, which allows for the state-space discretization errors. For more details on growth bounds, please refer to (Reissig, Weber, and Rungger, 2016).","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"ngrowthbound = 10; # Runge-Kutta pre-scaling\nA_diag = diagm(diag(A));\nA_abs = abs.(A) - abs.(A_diag) + A_diag\nL_growthbound = x -> abs.(A)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Finally we define the bounds on the input noise sysnoise and for the measurement noise measnoise of the system","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"measnoise = SVector(0.0, 0.0);\nsysnoise = SVector(0.0, 0.0);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"And now the instantiation of the ControlSystem","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"contsys = ST.discretize_system_with_growth_bound(\n    tstep,\n    F_sys,\n    L_growthbound,\n    sysnoise,\n    measnoise,\n    nsys,\n    ngrowthbound,\n);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"With that in hand, we can now proceed to the construction of a symbolic model of our system","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"symmodel = SY.NewSymbolicModelListList(domainX, domainU);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The method compute_symmodel_from_controlsystem! builds the transitions of the symbolic control system based on the provided domains and the dynamics defined in contsys","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"SY.compute_symmodel_from_controlsystem!(symmodel, contsys)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Let us now explore what transitions have been created considering, for instance, the state x=[1.1  1.3] and the input u=-1. First, let us pin point the cell in the grid associated with this state and this input. The method get_pos_by_coord returns a tuple of integers defining the indices of a cell coontaining a given coordinate.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"xpos = DO.get_pos_by_coord(Xgrid, SVector(1.1, 1.3))\nupos = DO.get_pos_by_coord(Ugrid, SVector(-1))","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"On the other hand, get_coord_by_pos returns the coordinates of the center of a cell defined by its indices.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"x = DO.get_coord_by_pos(Xgrid, xpos)\nu = DO.get_coord_by_pos(Ugrid, upos)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Now we create the vector post to receive the number of all the cells that are in the Post of x under u.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"post = Int[]\nSY.compute_post!(post, symmodel.autom, symmodel.xpos2int[xpos], symmodel.upos2int[upos])","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"It is important to highlight the differences between xpos and the elements of post. The Tuple xpos contains information about a cell with respect to the grid Xgrid whereas the elements of post are Int's containing an internal code of each cell added to the Symbolic Model symmodel. To alterante between the two different representations we use the dictionaries xint2pos and xpos2int. Similarly, the same can be said about upos. That said, we can build a domain of Post of xpos under upos as following:","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"domainPostx = DO.DomainList(Xgrid);\nfor pos in symmodel.xint2pos[post]\n    DO.add_pos!(domainPostx, pos)\nend","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Let us visualize this","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n);\nxlims!(-2, 2)\nylims!(-2, 2)\ndims = [1, 2]\n\nplot!(domainX; fc = \"white\", dims = dims);\ndomainx = DO.DomainList(Xgrid);\nDO.add_pos!(domainx, xpos)\nplot!(domainx; fc = \"blue\", dims = dims);\nplot!(domainPostx; fc = \"green\", dims = dims)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In the previous picture, we have the state space lattice in white, the chosen cell xpos in blue and the corresponding Post domain in green. The argument vars given to the Plot functions refer to the projection of the state space onto the subspace of variables 1 and 2. In this case this is an identity mapping but for higher-order systems, this projection is useful to visualize the behavior of the system on a 2-dimensional space.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"EditURL = \"../examples/solvers/DC-DC converter.jl\"","category":"page"},{"location":"generated/DC-DC converter/#Example:-DC-DC-converter-solved-by-[Uniform-grid-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"DC-DC converter","title":"Example: DC-DC converter solved by Uniform grid abstraction.","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"We consider a boost DC-DC converter which has been widely studied from the point of view of hybrid control, see for example in  [1, V.A],[2],[3]. This is a safety problem for a switching system.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"(Image: Boost DC-DC converter.)","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"The state of the system is given by x(t) = beginbmatrix i_l(t)  v_c(t) endbmatrix^top. The switching system has two modes consisting in two-dimensional affine dynamics:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"dotx = f_p(x) = A_p x + b_pquad p=12","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"with","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"A_1 = beginbmatrix -fracr_lx_l 0  0  -frac1x_cfrac1r_0+r_c  endbmatrix A_2= beginbmatrix -frac1x_lleft(r_l+fracr_0r_cr_0+r_cright)  -frac1x_lfracr_0r_0+r_c   frac1x_cfracr_0r_0+r_c    -frac1x_cfrac1r_0+r_c  endbmatrix b_1 = b_2 = beginbmatrix fracv_sx_l0endbmatrix","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"The goal is to design a controller to keep the state of the system in a safety region around the reference desired value, using as input only the switching signal. In order to study the concrete system and its symbolic abstraction in a unified framework, we will solve the problem for the sampled system with a sampling time tau. For the construction of the relations in the abstraction, it is necessary to over-approximate attainable sets of a particular cell. In this example, we consider the use of a growth bound function  [4, VIII.2, VIII.5] which is one of the possible methods to over-approximate attainable sets of a particular cell based on the state reach by its center.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"First, let us import StaticArrays and Plots.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"using StaticArrays, Plots","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"At this point, we import the useful Dionysos sub-modules.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"using Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst SY = DI.Symbolic\nconst OP = DI.Optim\nconst AB = OP.Abstraction","category":"page"},{"location":"generated/DC-DC converter/#Definition-of-the-system","page":"DC-DC converter","title":"Definition of the system","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"we can import the module containing the DCDC problem like this","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"include(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"dc_dc.jl\"))","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"and we can instantiate the DC system with the provided system","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"concrete_problem = DCDC.problem()\nconcrete_system = concrete_problem.system\n\nx0 = SVector(0.0, 0.0)\nhx = SVector(2.0 / 4.0e3, 2.0 / 4.0e3)\nstate_grid = DO.GridFree(x0, hx)\nu0 = SVector(1)\nhu = SVector(1)\ninput_grid = DO.GridFree(u0, hu)\n\nusing JuMP\noptimizer = MOI.instantiate(AB.UniformGridAbstraction.Optimizer)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"concrete_problem\"), concrete_problem)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"state_grid\"), state_grid)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"input_grid\"), input_grid)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"jacobian_bound\"), DCDC.jacobian_bound())\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"time_step\"), 0.5)\nMOI.optimize!(optimizer)\n\nabstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_controller\"))\nconcrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_controller\"))","category":"page"},{"location":"generated/DC-DC converter/#Trajectory-display","page":"DC-DC converter","title":"Trajectory display","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"We choose the number of steps nsteps for the sampled system, i.e. the total elapsed time: nstep*tstep as well as the true initial state x0 which is contained in the initial state-space defined previously.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"nstep = 300\nx0 = SVector(1.2, 5.6)\ncontrol_trajectory = ST.get_closed_loop_trajectory(\n    MOI.get(optimizer, MOI.RawOptimizerAttribute(\"discretized_system\")),\n    concrete_controller,\n    x0,\n    nstep,\n)\n\nfig = plot(; aspect_ratio = :equal);\nplot!(concrete_system.X);\nplot!(control_trajectory)","category":"page"},{"location":"generated/DC-DC converter/#Example:-DC-DC-converter-solved-by-[Uniform-grid-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers)-by-exploiting-the-incremental-stability-of-the-system.","page":"DC-DC converter","title":"Example: DC-DC converter solved by Uniform grid abstraction by exploiting the incremental stability of the system.","text":"","category":"section"},{"location":"generated/DC-DC converter/#Definition-of-the-system-2","page":"DC-DC converter","title":"Definition of the system","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"we can import the module containing the DCDC problem like this","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"include(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"dc_dc.jl\"))","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"and we can instantiate the DC system with the provided system","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"concrete_problem = DCDC.problem()\nconcrete_system = concrete_problem.system\n\norigin = SVector(0.0, 0.0)\nη = (2 / 4.0) * 10^(-3)","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Note: In the following, P and ϵ are computed by hand, but their computation is not crucial since they only affect the visualization of the abstraction. See https://github.com/dionysos-dev/Dionysos.jl/issues/345","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"ϵ = 0.1 * 0.01\nP = SMatrix{2, 2}(1.0224, 0.0084, 0.0084, 1.0031)\nstate_grid = DO.GridEllipsoidalRectangular(origin, SVector(η, η), P / ϵ, concrete_system.X)\n\nu0 = SVector(1)\nhu = SVector(1)\ninput_grid = DO.GridFree(u0, hu)\n\noptimizer = MOI.instantiate(AB.UniformGridAbstraction.Optimizer)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"concrete_problem\"), concrete_problem)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"state_grid\"), state_grid)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"input_grid\"), input_grid)\nMOI.set(\n    optimizer,\n    MOI.RawOptimizerAttribute(\"approx_mode\"),\n    Dionysos.Optim.Abstraction.UniformGridAbstraction.DELTA_GAS,\n)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"δGAS\"), true)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"time_step\"), 0.5)\nMOI.optimize!(optimizer)\n\nabstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_controller\"))\nconcrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_controller\"))","category":"page"},{"location":"generated/DC-DC converter/#Trajectory-display-2","page":"DC-DC converter","title":"Trajectory display","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"We choose the number of steps nsteps for the sampled system, i.e. the total elapsed time: nstep*tstep as well as the true initial state x0 which is contained in the initial state-space defined previously.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"nstep = 300\nx0 = SVector(1.2, 5.6)\ncontrol_trajectory = ST.get_closed_loop_trajectory(\n    MOI.get(optimizer, MOI.RawOptimizerAttribute(\"discretized_system\")),\n    concrete_controller,\n    x0,\n    nstep,\n)\n\nfig = plot(; aspect_ratio = :equal);\nplot!(concrete_system.X);\nplot!(control_trajectory)","category":"page"},{"location":"generated/DC-DC converter/#References","page":"DC-DC converter","title":"References","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"A. Girard, G. Pola and P. Tabuada, \"Approximately Bisimilar Symbolic Models for Incrementally Stable Switched Systems,\" in IEEE Transactions on Automatic Control, vol. 55, no. 1, pp. 116-126, Jan. 2010.\nS. Mouelhi, A. Girard, and G. Gössler. “CoSyMA: a tool for controller synthesis using multi-scale abstractions”. In: HSCC. ACM. 2013, pp. 83–88.\nA. Girard. “Controller synthesis for safety and reachability via approximate bisimulation”. In: Automatica 48.5 (2012), pp. 947–953.\nG. Reissig, A. Weber and M. Rungger, \"Feedback Refinement Relations for the Synthesis of Symbolic Controllers,\" in IEEE Transactions on Automatic Control, vol. 62, no. 4, pp. 1781-1796.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"EditURL = \"../examples/solvers/Lazy-abstraction-reachability.jl\"","category":"page"},{"location":"generated/Lazy-abstraction-reachability/#Example:-Reachability-problem-solved-by-[Lazy-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"Lazy-abstraction-reachability","title":"Example: Reachability problem solved by Lazy abstraction.","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"This is a optimal reachability problem for a continuous system.","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"In order to study the concrete system and its symbolic abstraction in a unified framework, we will solve the problem for the sampled system with a sampling time tau. For the construction of the relations in the abstraction, it is necessary to over-approximate attainable sets of a particular cell. In this example, we consider the used of a growth bound function  [1, VIII.2, VIII.5] which is one of the possible methods to over-approximate attainable sets of a particular cell based on the state reach by its center.","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"For this reachability problem, the abstraction controller is built using a solver that lazily builds the abstraction, constructing the abstraction at the same time as the controller.","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"First, let us import StaticArrays and Plots.","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"using StaticArrays, JuMP, Plots","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"At this point, we import Dionysos.","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"using Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst SY = DI.Symbolic\nconst PR = DI.Problem\nconst OP = DI.Optim\nconst AB = OP.Abstraction\n\ninclude(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"simple_problem.jl\"))\n\n# specific functions\nfunction post_image(abstract_system, concrete_system, xpos, u)\n    Xdom = abstract_system.Xdom\n    x = DO.get_coord_by_pos(Xdom.grid, xpos)\n    Fx = concrete_system.f_eval(x, u)\n    r = Xdom.grid.h / 2.0 + concrete_system.measnoise\n    Fr = r\n\n    rectI = DO.get_pos_lims_outer(Xdom.grid, UT.HyperRectangle(Fx .- Fr, Fx .+ Fr))\n    ypos_iter = Iterators.product(DO._ranges(rectI)...)\n    over_approx = []\n    allin = true\n    for ypos in ypos_iter\n        ypos = DO.set_in_period_pos(Xdom, ypos)\n        if !(ypos in Xdom)\n            allin = false\n            break\n        end\n        target = SY.get_state_by_xpos(abstract_system, ypos)[1]\n        push!(over_approx, target)\n    end\n    return allin ? over_approx : []\nend\n\nfunction pre_image(abstract_system, concrete_system, xpos, u)\n    grid = abstract_system.Xdom.grid\n    x = DO.get_coord_by_pos(grid, xpos)\n    potential = Int[]\n    x_prev = concrete_system.f_backward(x, u)\n    xpos_cell = DO.get_pos_by_coord(grid, x_prev)\n    n = 2\n    for i in (-n):n\n        for j in (-n):n\n            x_n = (xpos_cell[1] + i, xpos_cell[2] + j)\n            x_n = DO.set_in_period_pos(abstract_system.Xdom, x_n)\n            if x_n in abstract_system.Xdom\n                cell = SY.get_state_by_xpos(abstract_system, x_n)[1]\n                if !(cell in potential)\n                    push!(potential, cell)\n                end\n            end\n        end\n    end\n    return potential\nend\n\nfunction compute_reachable_set(rect::UT.HyperRectangle, concrete_system, Udom)\n    r = (rect.ub - rect.lb) / 2.0 + concrete_system.measnoise\n    Fr = r\n    x = UT.get_center(rect)\n    n = UT.get_dims(rect)\n    lb = fill(Inf, n)\n    ub = fill(-Inf, n)\n    for upos in DO.enum_pos(Udom)\n        u = DO.get_coord_by_pos(Udom.grid, upos)\n        Fx = concrete_system.f_eval(x, u)\n        lb = min.(lb, Fx .- Fr)\n        ub = max.(ub, Fx .+ Fr)\n    end\n    lb = SVector{n}(lb)\n    ub = SVector{n}(ub)\n    return UT.HyperRectangle(lb, ub)\nend\nminimum_transition_cost(symmodel, contsys, source, target) = 1.0\n\nconcrete_problem = SimpleProblem.problem()\nconcrete_system = concrete_problem.system\n\nhx = [0.5, 0.5]\nu0 = SVector(0.0, 0.0)\nhu = SVector(0.5, 0.5)\nUgrid = DO.GridFree(u0, hu)\nhx_heuristic = [1.0, 1.0] * 1.5\nmaxIter = 100\n\noptimizer = MOI.instantiate(AB.LazyAbstraction.Optimizer)\n\nAB.LazyAbstraction.set_optimizer!(\n    optimizer,\n    concrete_problem,\n    maxIter,\n    pre_image,\n    post_image,\n    compute_reachable_set,\n    minimum_transition_cost,\n    hx_heuristic,\n    hx,\n    Ugrid,\n)","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"Build the abstraction and solve the optimal control problem using A* algorithm","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"using Suppressor\n@suppress begin\n    MOI.optimize!(optimizer)\nend","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"Get the results","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_system\"))\nabstract_problem = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_problem\"))\nabstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_controller\"))\nconcrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_controller\"))\nabstract_lyap_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_lyap_fun\"))\nconcrete_lyap_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_lyap_fun\"));\nnothing #hide","category":"page"},{"location":"generated/Lazy-abstraction-reachability/#Simulation","page":"Lazy-abstraction-reachability","title":"Simulation","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"We define the cost and stopping criteria for a simulation","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"cost_eval(x, u) = UT.function_value(concrete_problem.transition_cost, x, u)\nreached(x) = x ∈ concrete_problem.target_set\nnstep = typeof(concrete_problem.time) == PR.Infinity ? 100 : concrete_problem.time; # max num of steps\nnothing #hide","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"We simulate the closed loop trajectory","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"x0 = UT.get_center(concrete_problem.initial_set)\ncost_control_trajectory = ST.get_closed_loop_trajectory(\n    concrete_system.f_eval,\n    concrete_controller,\n    cost_eval,\n    x0,\n    nstep;\n    stopping = reached,\n    noise = false,\n)\n\ncost_bound = concrete_lyap_fun(x0)\ncost_true = sum(cost_control_trajectory.costs.seq);\nprintln(\"Goal set reached\")\nprintln(\"Guaranteed cost:\\t $(cost_bound)\")\nprintln(\"True cost:\\t\\t $(cost_true)\")","category":"page"},{"location":"generated/Lazy-abstraction-reachability/#Display-the-results","page":"Lazy-abstraction-reachability","title":"Display the results","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/#Display-the-specifications-and-domains","page":"Lazy-abstraction-reachability","title":"Display the specifications and domains","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"fig = plot(; aspect_ratio = :equal);\n#We display the concrete domain\nplot!(concrete_system.X; color = :yellow, opacity = 0.5);\n\n#We display the abstract domain\nplot!(abstract_system.Xdom; color = :blue, opacity = 0.5);\n\n#We display the concrete specifications\nplot!(concrete_problem.initial_set; color = :green, opacity = 0.8);\nplot!(concrete_problem.target_set; dims = [1, 2], color = :red, opacity = 0.8);\n\n#We display the concrete trajectory\nplot!(cost_control_trajectory; ms = 0.5)","category":"page"},{"location":"generated/Lazy-abstraction-reachability/#Display-the-abstraction-and-Lyapunov-like-function","page":"Lazy-abstraction-reachability","title":"Display the abstraction and Lyapunov-like function","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"fig = plot(; aspect_ratio = :equal);\nplot!(\n    abstract_system;\n    dims = [1, 2],\n    cost = true,\n    lyap_fun = optimizer.lyap_fun,\n    label = false,\n)","category":"page"},{"location":"generated/Lazy-abstraction-reachability/#Display-the-Bellman-like-value-function-(heuristic)","page":"Lazy-abstraction-reachability","title":"Display the Bellman-like value function (heuristic)","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"fig = plot(; aspect_ratio = :equal)\nplot!(\n    optimizer.abstract_system_heuristic;\n    arrowsB = false,\n    dims = [1, 2],\n    cost = true,\n    lyap_fun = optimizer.bell_fun,\n    label = false,\n)","category":"page"},{"location":"generated/Lazy-abstraction-reachability/#Display-the-results-of-the-A*-algorithm","page":"Lazy-abstraction-reachability","title":"Display the results of the A* algorithm","text":"","category":"section"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"fig = plot(; aspect_ratio = :equal)\nplot!(optimizer.lazy_search_problem)\nplot!(cost_control_trajectory; color = :black)\n\ndisplay(fig)","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"","category":"page"},{"location":"generated/Lazy-abstraction-reachability/","page":"Lazy-abstraction-reachability","title":"Lazy-abstraction-reachability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"EditURL = \"../examples/solvers/Gol, Lazar & Belta (2013).jl\"","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/#Example:-Gol,-Lazar-and-Belta-(2013)-solved-by-[Bemporad-Morari](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"Gol, Lazar & Belta (2013)","title":"Example: Gol, Lazar and Belta (2013) solved by Bemporad Morari.","text":"","category":"section"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"(Image: Binder) (Image: nbviewer) This example reproduces parts of the numerical results of [3]. A similar example reproducing all results of [3] is available as a codeocean capsule in [4].","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"This example was borrowed from [1, Example VIII.A] and tackles an optimal control for the hybrid system with state evolution governed by","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"x(k+1) = beginbmatrix 1  1  0  1 endbmatrixx(k) + beginbmatrix 05  10 endbmatrix u(k)","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"The goal is to take the state vector toward a target set XT by visiting one of the squares A or B and avoiding the obstacles O1 and O2","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"First, let us import CDDLib, GLPK, OSQP, JuMP, Pavito and Ipopt","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"import CDDLib\nimport GLPK\nimport OSQP\nusing JuMP\nimport Pavito\nimport HiGHS\nimport Ipopt","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"At this point we import Dionysos","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"using Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst ST = DI.System\nconst OP = DI.Optim","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"And the file defining the hybrid system for this problem","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"include(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"gol_lazar_belta.jl\"))","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"Now we instantiate our optimal control problem using the function provided by GolLazarBelta.jl","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"problem = GolLazarBelta.problem(CDDLib.Library(), Float64);\nnothing #hide","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"Finally, we select the method presented in [2] as our optimizer","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"qp_solver = optimizer_with_attributes(\n    OSQP.Optimizer,\n    \"eps_abs\" => 1e-8,\n    \"eps_rel\" => 1e-8,\n    \"max_iter\" => 100000,\n    MOI.Silent() => true,\n);\n\nmip_solver = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent() => true);\n\ncont_solver = optimizer_with_attributes(Ipopt.Optimizer, MOI.Silent() => true);\n\nmiqp_solver = optimizer_with_attributes(\n    Pavito.Optimizer,\n    \"mip_solver\" => mip_solver,\n    \"cont_solver\" => cont_solver,\n    MOI.Silent() => true,\n);\n\nalgo = optimizer_with_attributes(\n    OP.BemporadMorari.Optimizer{Float64},\n    \"continuous_solver\" => qp_solver,\n    \"mixed_integer_solver\" => miqp_solver,\n    \"indicator\" => false,\n    \"log_level\" => 0,\n);\nnothing #hide","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"and use it to solve the given problem, with the help of the abstraction layer MathOptInterface provided by JuMP","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"optimizer = MOI.instantiate(algo)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"problem\"), problem)\nMOI.optimize!(optimizer)","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"We check the solver time","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"MOI.get(optimizer, MOI.SolveTimeSec())","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"the termination status","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"termination = MOI.get(optimizer, MOI.TerminationStatus())","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"the objective value","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"objective_value = MOI.get(optimizer, MOI.ObjectiveValue())","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"and recover the corresponding continuous trajectory","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"xu = MOI.get(optimizer, ST.ContinuousTrajectoryAttribute());\nnothing #hide","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/#A-little-bit-of-data-visualization-now:","page":"Gol, Lazar & Belta (2013)","title":"A little bit of data visualization now:","text":"","category":"section"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"using Plots\nusing Polyhedra\nusing HybridSystems\nusing Suppressor\n\n#Initialize our canvas\nfig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n);\nxlims!(-10.5, 3.0)\nylims!(-10.5, 3.0)\n\n#Plot the discrete modes\nfor mode in states(problem.system)\n    t =\n        (problem.system.ext[:q_T] in [mode, mode + 11]) ? \"XT\" :\n        (\n            mode == problem.system.ext[:q_A] ? \"A\" :\n            (\n                mode == problem.system.ext[:q_B] ? \"B\" :\n                mode <= 11 ? string(mode) : string(mode - 11)\n            )\n        )\n    set = stateset(problem.system, mode)\n    plot!(set; color = :white)\n    UT.text_in_set_plot!(fig, set, t)\nend\n\n#Plot obstacles\nfor i in eachindex(problem.system.ext[:obstacles])\n    set = problem.system.ext[:obstacles][i]\n    plot!(set; color = :black, opacity = 0.5)\n    UT.text_in_set_plot!(fig, set, \"O$i\")\nend\n\n#Plot trajectory\nx0 = problem.initial_set[2]\nx_traj = [x0, xu.x...]\nplot!(fig, UT.DrawTrajectory(x_traj));\n\n#Plot initial point\nplot!(fig, UT.DrawPoint(x0); color = :blue)\nannotate!(fig, x0[1], x0[2] - 0.5, \"x0\")","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/#References","page":"Gol, Lazar & Belta (2013)","title":"References","text":"","category":"section"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"Gol, E. A., Lazar, M., & Belta, C. (2013). Language-guided controller synthesis for linear systems. IEEE Transactions on Automatic Control, 59(5), 1163-1176.\nBemporad, A., & Morari, M. (1999). Control of systems integrating logic, dynamics, and constraints. Automatica, 35(3), 407-427.\nLegat B., Bouchat J., Jungers R. M. (2021). Abstraction-based branch and bound approach to Q-learning for hybrid optimal control. 3rd Annual Learning for Dynamics & Control Conference, 2021.\nLegat B., Bouchat J., Jungers R. M. (2021). Abstraction-based branch and bound approach to Q-learning for hybrid optimal control. https://www.codeocean.com/. https://doi.org/10.24433/CO.6650697.v1.","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/Problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"reference/Problem/","page":"Problem","title":"Problem","text":"This folder contains structures that are used to encode which kind of problem you want to solve. Each problem is encoded as a ProblemType.","category":"page"},{"location":"reference/Problem/","page":"Problem","title":"Problem","text":"Dionysos.Problem.ProblemType","category":"page"},{"location":"reference/Problem/#Dionysos.Problem.ProblemType","page":"Problem","title":"Dionysos.Problem.ProblemType","text":"The structure \n\nProblemType\n\nis the abstract type which defines a problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/Problem/","page":"Problem","title":"Problem","text":"So far, two types of problems have been considered: the reach-avoid optimal control problems and the safety control problems.","category":"page"},{"location":"reference/Problem/","page":"Problem","title":"Problem","text":"Dionysos.Problem.OptimalControlProblem\nDionysos.Problem.SafetyProblem","category":"page"},{"location":"reference/Problem/#Dionysos.Problem.OptimalControlProblem","page":"Problem","title":"Dionysos.Problem.OptimalControlProblem","text":"The structure \n\nOptimalControlProblem{S, XI, XT, XC, TC, T}\n\nencodes an optimal control problem where \n\nS is the system,\nXI is the initial set, \nXT is the target set,\nXC is the state cost,\nTC is transistion cost and\nT is the number of allowed time steps\n\n\n\n\n\n","category":"type"},{"location":"reference/Problem/#Dionysos.Problem.SafetyProblem","page":"Problem","title":"Dionysos.Problem.SafetyProblem","text":"The structure \n\nSafetyProblem{S, XI, XS, T}\n\nencodes a safety problem where\n\nS is the system,\nXI is the initial set, \nXS is the safe set and\nT is the number of allowed time steps\n\n\n\n\n\n","category":"type"},{"location":"developers/git/#Git-recommended-workflow","page":"Git","title":"Git recommended workflow","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Git is very flexible and this can be a bit too much at first. This guide provides a workflow that should allow you to get things done and not lead you in any tricky situations. Moreover, it guarantees that the whole team has the same setup. This guide assumes you have already followed and completed your Set up. This guide assumes that your Github login is jdupont. Replace it by the appropriate login since that is not the case.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"You can be in 2 situations:","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"You don't have write access to origin. If you don't know what this means, it means you are in that situation. Once you have enough mastery of Git, we might give you write access but it's best to start in this situation.\nYou have write access to origin. This means you can push directly to master which you should never do. We only give you write access when we trust that you won't mess up.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"We have a master branch that contains the latest version of all merged changes. There is three master branches:","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"origin/master: that is the branch at https://github.com/dionysos-dev/Dionysos.jl, it is always the most up to date.\nYour local master branch: that is the state of the branch on your computer. It may be a few commits behind origin/master as they do not synchronize automatically. You can update it by following Switch to the master branch and update it.\njdupont/master: that is the branch of your fork https://github.com/jdupont/Dionysos.jl, it may be many commits behind your local master and even more commits behind origin/master but we don't care much because we won't use it so you don't have to update it. Once you have write access to origin, you care even less if that was possible.","category":"page"},{"location":"developers/git/#Workflow","page":"Git","title":"Workflow","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"The workflow is as follows. Your contributions should be grouped into small chunks that bring Dionysos from a working state (which is the current version of origin/master) to a new working state containing your improvements. In order to do that, you do the following for every chunk.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Switch to the master branch and update it;\nthen you Create a new branch (let's call it mybranch but it should be a new name for every new small chunk);\nthen you make your changes on your computer...\nthen you Format your code with JuliaFormatter.jl, so that the whole code has the same format; \nthen you Commit your changes, this will update your local version of mybranch;\nthen you Push your changes, this will update the version of mybranch in your fork (resp. origin) if you don't have write access) (resp. you have write access)) ; \nthen you Create a pull request on Github, note that if the code was not properly formatted, the pull request will raise an error on Github;\nthen you should receive reviews asking you to do changes. Do these changes on your computer and push them. To do that, Switch branches to mybranch then follow steps 4) and then 5) again;\nyou might need to Resolve conflicts, especially if you did not follow step 1);\nOnce your branch has been merged, Delete your branch and go back to step 1) for a new chunk.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"If you want to make a change independent from the change you are currently making go back to step 1) use another branch name, say myotherbranch. Once you want to go back to the changes you were doing previously, Switch branches back to mybranch. Changing branches requires you that you have committed your changes so you should at least finish step 4) in order to do that. It's best to also have completed step 5) so that your changes are backed up in the cloud in case something happens to your computer.","category":"page"},{"location":"developers/git/#Fork-and-add-your-remote","page":"Git","title":"Fork and add your remote","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"These are the steps that should be done only the first time when you set up.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"At first, you don't have write access, so create a fork https://github.com/jdupont/Dionysos.jl by going to https://github.com/dionysos-dev/Dionysos.jl and click on the \"Fork\" button on the top right. You should then add this as a remote as detailed below.","category":"page"},{"location":"developers/git/#VSCode","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Switch to Source Control by pressing Ctrl+Shift+G then on the three horizontal dots on the top right of the left pane then Remote then Add remote... then enter https://github.com/jdupont/Dionysos.jl.git (replace jdupont by your Github login!) and then jdupont.","category":"page"},{"location":"developers/git/#Git-bash","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Then, add the remote as follows:","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git remote add jdupont https://github.com/jdupont/Dionysos.jl.git","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Your remotes should be (the order of the lines is not important):","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git remote -v\njdupont\thttps://github.com/jdupont/Dionysos.jl.git (fetch)\njdupont\thttps://github.com/jdupont/Dionysos.jl.git (push)\norigin\thttps://github.com/dionysos-dev/Dionysos.jl.git (fetch)\norigin\thttps://github.com/dionysos-dev/Dionysos.jl.git (push)","category":"page"},{"location":"developers/git/#Switch-to-the-master-branch-and-update-it","page":"Git","title":"Switch to the master branch and update it","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"This should be before any new change! See Workflow.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"If the procedure below fails or you get a message about a need to create a merge, it means you have commit changes to your local master branch, you did not follow the Workflow. Contact us to get help, we will be mad at you for not following the Workflow but we will still help you.","category":"page"},{"location":"developers/git/#VSCode-2","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Click on the branch on the lower left and enter master. Now, click on the rotating arrows on the lower left at the right of master to update it.","category":"page"},{"location":"developers/git/#Git-bash-2","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Before you start working on something new, pull any new changes made by the team to the master branch of your computer.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git checkout master # Switch to the master branch of your computer\n$ git fetch origin master # Fetch the new commits of the master branch on Github\n$ git merge --ff-only origin/master # Merge the new commits into the master branch of your computer","category":"page"},{"location":"developers/git/#Create-a-new-branch","page":"Git","title":"Create a new branch","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Start by Switch to the master branch and update it. Create a new branch (choose a branch name, let's suppose it is mybranch) and switch to it.","category":"page"},{"location":"developers/git/#VSCode-3","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Click on master on the lower left and then + Create new branch... then write mybranch.","category":"page"},{"location":"developers/git/#Git-bash-3","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git branch mybranch # Creates a new branch `mybranch`\n$ git checkout mybranch # Switch to the new branch `mybranch`","category":"page"},{"location":"developers/git/#Commit-your-changes","page":"Git","title":"Commit your changes","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Before doing any changes, make sure you Switch branches to the right branch (which should be mybranch). Once you have made changes, they are saved on your disc but the Git history has not been modified yet; neither your local branches nor the remote one on origin or your fork! You should first stage changes (this means selecting changes you want to commit and hence to be applied on the chunk of changes you suggest to make to Dionysos in the Pull Request) and then create the commit with a message. Usually, you want to stage every file; both the modified ones and the untracked ones because the \"untracked\" ones you don't want to add should be listed in the .gitignore file and hence should not show up. The only exception is the file docs/Project.toml since you may have changed it by adding Dionysos in Build the documentation but you don't want to push that, you want to keep these changes to your computer only.","category":"page"},{"location":"developers/git/#VSCode-4","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Switch to Source Control by pressing Ctrl+Shift+G.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"You will see the modified files with a M and the untracked files with a U. Click on the \"+\" to stage all the changes of a file. Once all files have been staged, Write a message in the field above the \"Commit\" blue button. Then press on the \"Commit\" blue button.","category":"page"},{"location":"developers/git/#Git-bash-4","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git checkout mybranch # Make sure you are not on the `master` branch!\n$ git status # Shows modified and untracked files\n$ git add foobar.jl # Stage file `foobar.jl`, replace it by the files you want to stage\n$ git commit -m \"Commit message\" # Replace \"Commit message\" by a very short message about your changes","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"To unstage every file, do","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git reset","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Alternatively, the following adds all modified and untracked files.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git add .","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Another option is the following which adds all modified files and commits them directly.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git commit -am \"Commit message\"","category":"page"},{"location":"developers/git/#Push-your-changes","page":"Git","title":"Push your changes","text":"","category":"section"},{"location":"developers/git/#VSCode-5","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Switch to Source Control by pressing Ctrl+Shift+G then on the three horizontal dots on the top right of the left pane then on \"push\". If it is the first time you push this branch, it will ask \"The branch mybranch has no remote branch. Would you like to publish this branch ?\"; answer with \"Ok\". Then it will ask which remote to push to, select jdupont if you don't have write access or origin if you have write access.","category":"page"},{"location":"developers/git/#Git-bash-5","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"If you don't have write access, push to your fork:","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git push jdupont mybranch","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"Otherwise, push to origin:","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git push origin mybranch","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"If this fails, it means you don't have write access or that you chose a name of branch that already exists.","category":"page"},{"location":"developers/git/#Delete-your-branch","page":"Git","title":"Delete your branch","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First, Switch to the master branch and update it. Otherwise, Git won't see that the branch is merged and will disallow you to delete it to avoid losing your work.","category":"page"},{"location":"developers/git/#VSCode-6","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"Switch to Source Control by pressing Ctrl+Shift+G then on the three horizontal dots on the top right of the left pane then on \"Branch\" then \"Delete Branch...\" then write or select mybranch.","category":"page"},{"location":"developers/git/#Git-bash-6","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git checkout master\n$ git branch -d mybranch","category":"page"},{"location":"developers/git/#Resolve-conflicts","page":"Git","title":"Resolve conflicts","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"By the time you have created new branch, other developers may have made changes to the master branch at the same lines of the same files as the changes in some of your branch. In that case, Github won't allow your pull request to be merged as it does not know whether it should take the changes of your branch or the changes of master. To fix the conflicts, start Updating the master branch and then do","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git checkout mybranch\n$ git rebase master","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"The rebase will stop at every conflicting commit and you will have to, edit the conflicting files and edit parts of the file like","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"<<<<<<< HEAD\nchanges on master\n=======\nchanges on your branch\n>>>>>>> mybranch","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"and choose the changes that should be kept. Then you should git add the conflicting files, run git rebase --continue. See here for more information on this. In case you have may conflicting commits, the rebase can be tedious, you will even have to resolve conflicts for some changes in some earlier commit even if you reverted these changes in a later commit. To avoid this issue, it is recommended to first squash your commits into a single one. To do that, use","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git rebase -i master","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"and replace pick by s for all commits except the top one and then follow the instructions, see here for more details.","category":"page"},{"location":"developers/git/#Switch-branches","page":"Git","title":"Switch branches","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"To switch to the branch mybranch, do the following.","category":"page"},{"location":"developers/git/#VSCode-7","page":"Git","title":"VSCode","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"On the bottom left, you should see a sort of \"Y\" symbol with empty circles at the three leaves. On the right, you see the current branch. Click on it and then write or select mybranch.","category":"page"},{"location":"developers/git/#Git-bash-7","page":"Git","title":"Git bash","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"First Start Git bash.","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"$ git checkout mybranch","category":"page"},{"location":"developers/git/#Format-your-code","page":"Git","title":"Format your code","text":"","category":"section"},{"location":"developers/git/","page":"Git","title":"Git","text":"To format your code, run the following in your Julia REPL. Make sure you have added JuliaFormatter.jl before. ","category":"page"},{"location":"developers/git/","page":"Git","title":"Git","text":"julia> using JuliaFormatter; format(\".\")","category":"page"},{"location":"reference/Symbolic/#Symbolic","page":"Symbolic","title":"Symbolic","text":"","category":"section"},{"location":"reference/Symbolic/","page":"Symbolic","title":"Symbolic","text":"This folder contains the data structures needed to encode the different abstractions.","category":"page"},{"location":"reference/Symbolic/","page":"Symbolic","title":"Symbolic","text":"Dionysos.Symbolic.SymbolicModel","category":"page"},{"location":"reference/Symbolic/#Dionysos.Symbolic.SymbolicModel","page":"Symbolic","title":"Dionysos.Symbolic.SymbolicModel","text":"SymbolicModel{N, M}\n\nis the abtract type which defines a symbolic model.\n\n\n\n\n\n","category":"type"},{"location":"reference/Symbolic/","page":"Symbolic","title":"Symbolic","text":"Dionysos.Symbolic.SymbolicModelList\nDionysos.Symbolic.LazySymbolicModel\nDionysos.Symbolic.compute_symmodel_from_hybridcontrolsystem!","category":"page"},{"location":"reference/Symbolic/#Dionysos.Symbolic.SymbolicModelList","page":"Symbolic","title":"Dionysos.Symbolic.SymbolicModelList","text":"SymbolicModelList{N, M, S1 <: DO.DomainType{N}, S2 <: DO.DomainType{M}, A} <: SymbolicModel{N, M}\n\nis one implementation of the SymbolicModel type for classical abstraction-based methods, i.e. when the whole domain is partitioned/covered.\n\n\n\n\n\n","category":"type"},{"location":"reference/Symbolic/#Dionysos.Symbolic.LazySymbolicModel","page":"Symbolic","title":"Dionysos.Symbolic.LazySymbolicModel","text":"LazySymbolicModel{N, M, S1 <: DO.DomainType{N}, S2 <: DO.DomainType{M}, A} <: SymbolicModel{N, M}\n\nis one implementation of the SymbolicModel type for the lazy abstraction-based methods, i.e. when a subset of the domain is partitioned/covered.\n\n\n\n\n\n","category":"type"},{"location":"reference/Symbolic/#Dionysos.Symbolic.compute_symmodel_from_hybridcontrolsystem!","page":"Symbolic","title":"Dionysos.Symbolic.compute_symmodel_from_hybridcontrolsystem!","text":"compute_symmodel_from_hybridcontrolsystem!(symmodel::SymbolicModel{N}, transitionCost::AbstractDict, transitionCont::AbstractDict,\nhybridsys::AbstractHybridSystem, W, L, U, opt_sdp, opt_qp)\n\nBuilds an abstraction symmodel where the transitions have costs given in transitionCost and are parameterized by affine-feedback controllers in transitionCont. The concrete system  is hybridsys and W, L and U are defined as in _has_transition. An SDP optimizer opt_sdp and a QP optimizer opt_qp must be provided as JuMP optimizers.\n\n\n\n\n\n","category":"function"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"EditURL = \"../examples/solvers/Lazy-Ellipsoids-Abstraction.jl\"","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#Example:-Reachability-problem-solved-by-[Lazy-ellipsoid-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"Lazy-Ellipsoids-Abstraction","title":"Example: Reachability problem solved by Lazy ellipsoid abstraction.","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"using StaticArrays, LinearAlgebra, Random, IntervalArithmetic\nusing MathematicalSystems, HybridSystems\nusing JuMP, Mosek, MosekTools\nusing Plots, Colors\nusing Test\nRandom.seed!(0)\n\nusing Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst SY = DI.Symbolic\nconst PR = DI.Problem\nconst OP = DI.Optim\nconst AB = OP.Abstraction\n\ninclude(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"non_linear.jl\"))","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#First-example","page":"Lazy-Ellipsoids-Abstraction","title":"First example","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"concrete_problem = NonLinear.problem()\nconcrete_system = concrete_problem.system","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"Optimizer's parameters","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"const FALLBACK_URL = \"mosek://solve.mosek.com:30080\"\nsdp_opt = optimizer_with_attributes(Mosek.Optimizer, MOI.Silent() => true)\nMOI.set(sdp_opt, MOI.RawOptimizerAttribute(\"fallback\"), FALLBACK_URL)\n\nmaxδx = 100\nmaxδu = 10 * 2\nλ = 0.01\nk1 = 1\nk2 = 1\nRRTstar = false\ncontinues = false\nmaxIter = 100\n\noptimizer = MOI.instantiate(AB.LazyEllipsoidsAbstraction.Optimizer)\nAB.LazyEllipsoidsAbstraction.set_optimizer!(\n    optimizer,\n    concrete_problem,\n    sdp_opt,\n    maxδx,\n    maxδu,\n    λ,\n    k1,\n    k2,\n    RRTstar,\n    continues,\n    maxIter,\n)","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"Build the state feedback abstraction and solve the optimal control problem using RRT algorithm.","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"MOI.optimize!(optimizer)","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"Get the results","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_system\"))\nabstract_problem = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_problem\"))\nabstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_controller\"))\nconcrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_controller\"))\nabstract_lyap_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_lyap_fun\"))\nconcrete_lyap_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_lyap_fun\"));\nnothing #hide","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#Simulation","page":"Lazy-Ellipsoids-Abstraction","title":"Simulation","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"We define the cost and stopping criteria for a simulation","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"cost_eval(x, u) = UT.function_value(concrete_problem.transition_cost, x, u)\nreached(x) = x ∈ concrete_problem.target_set\nnstep = typeof(concrete_problem.time) == PR.Infinity ? 100 : concrete_problem.time; # max num of steps\nnothing #hide","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"We simulate the closed loop trajectory","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"x0 = concrete_problem.initial_set.c\ncost_control_trajectory = ST.get_closed_loop_trajectory(\n    concrete_system.f_eval,\n    concrete_controller,\n    cost_eval,\n    x0,\n    nstep;\n    stopping = reached,\n    noise = true,\n)\ncost_bound = concrete_lyap_fun(x0)\ncost_true = sum(cost_control_trajectory.costs.seq);\nprintln(\"Goal set reached\")\nprintln(\"Guaranteed cost:\\t $(cost_bound)\")\nprintln(\"True cost:\\t\\t $(cost_true)\")","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#Display-the-results","page":"Lazy-Ellipsoids-Abstraction","title":"Display the results","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#Display-the-specifications-and-domains","page":"Lazy-Ellipsoids-Abstraction","title":"Display the specifications and domains","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n    label = false,\n);\nxlabel!(\"\\$x_1\\$\");\nylabel!(\"\\$x_2\\$\");\ntitle!(\"Specifictions and domains\");\n\n#Display the concrete domain\nplot!(concrete_system.X; color = :yellow, opacity = 0.5, label = false);\n\n#Display the abstract domain\nplot!(abstract_system; arrowsB = false, cost = false, label = false);\n\n#Display the concrete specifications\nplot!(concrete_problem.initial_set; color = :green, label = false);\nplot!(concrete_problem.target_set; color = :red, label = false)","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#Display-the-abstraction","page":"Lazy-Ellipsoids-Abstraction","title":"Display the abstraction","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n);\ntitle!(\"Abstractions\");\nplot!(abstract_system; arrowsB = true, cost = false)","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/#Display-the-Lyapunov-function-and-the-trajectory","page":"Lazy-Ellipsoids-Abstraction","title":"Display the Lyapunov function and the trajectory","text":"","category":"section"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n);\nxlabel!(\"\\$x_1\\$\");\nylabel!(\"\\$x_2\\$\");\ntitle!(\"Trajectory and Lyapunov-like Fun.\");\n\nfor obs in concrete_system.obstacles\n    plot!(obs; color = :black)\nend\nplot!(abstract_system; arrowsB = false, cost = true);\nplot!(cost_control_trajectory; color = :black)","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"","category":"page"},{"location":"generated/Lazy-Ellipsoids-Abstraction/","page":"Lazy-Ellipsoids-Abstraction","title":"Lazy-Ellipsoids-Abstraction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"EditURL = \"../examples/solvers/Unicycle robot.jl\"","category":"page"},{"location":"generated/Unicycle robot/#Example:-Unicycle-Robot-solved-by-[Uniform-grid-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"Unicycle robot","title":"Example: Unicycle Robot solved by Uniform grid abstraction.","text":"","category":"section"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"This example was adapted from the numerical experiments in [1, Sec. 5] from Symbolically guided Model Predictive Control (SgMPC)  paper.. This is a control problem for a discrete-time nonlinear system.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Let us consider the 3-dimensional state space control system of the form","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"x_t+1 = f(x_t u_t)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"with f mathbbR^3  mathbbR^2 to mathbbR^3 given by","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"f(x (u_1 u_2)) = beginbmatrix x_1 + u_1 cos(x_3)  x_2 + u_1 sin(x_3)  x_3 + u_2  (textmod  2pi) endbmatrix","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"and with state and control constraints given by:","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"X = left (x_1 x_2)^T in mathbbR^2    x_1^2 - x_2^2 leq 4  4x_2^2 - x_1^2 leq 16 right","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"U = 02 2 times -1 1","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Here, (x_1 x_2) represents the 2D Cartesian coordinates and x_3 is the angular orientation of a mobile cart. The control inputs u_1 and u_2 are the linear and angular velocities. The control objective is to drive the mobile cart to a desired reference position x_r.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Considering this as a reachability problem, we will use it to showcase the capabilities of the Uniform grid abstraction solving discrete-time problem in Dionysos. The nonlinear constraints are handled as obstacles in the state-space.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"First, let us import StaticArrays and Plots.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"using StaticArrays, Plots","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"At this point, we import Dionysos and JuMP.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"using Dionysos, JuMP","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Define the problem using JuMP We first create a JuMP model:","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"model = Model(Dionysos.Optimizer)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Define the discretization step","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"hx = 0.1","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Define the state variables: x1(t), x2(t), x3(t) without specifying the start value since here it's a set. We will specify the start later using constraints.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"x_low = [-3.5, -2.6, -pi]\nx_upp = -x_low\n@variable(model, x_low[i] <= x[i = 1:3] <= x_upp[i])","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Define the control variables: u1(t), u2(t)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"@variable(model, -1 <= u[1:2] <= 1)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Define the dynamics, we do not include the remainder modulo 2π for Δ(x[3]). There are options to set periodic variables in Dionysos but that's not needed for this example.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"@constraint(model, Δ(x[1]) == x[1] + u[1] * cos(x[3]))\n@constraint(model, Δ(x[2]) == x[2] + u[1] * sin(x[3]))\n@constraint(model, Δ(x[3]) == x[3] + u[2])","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Define the initial and target sets","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"x_initial = [1.0, -1.7, 0.0]\nx_target = [sqrt(32) / 3, sqrt(20) / 3, -pi]\n\n@constraint(model, start(x[1]) in MOI.Interval(x_initial[1] - hx, x_initial[1] + hx))\n@constraint(model, start(x[2]) in MOI.Interval(x_initial[2] - hx, x_initial[2] + hx))\n@constraint(model, start(x[3]) in MOI.Interval(x_initial[3] - hx, x_initial[3] + hx))\n\n@constraint(model, final(x[1]) in MOI.Interval(x_target[1] - hx, x_target[1] + hx))\n@constraint(model, final(x[2]) in MOI.Interval(x_target[2] - hx, x_target[2] + hx))\n@constraint(model, final(x[3]) in MOI.Interval{Float64}(-pi, pi))","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Obstacle boundaries computed using the function get_obstacles below","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"function extract_rectangles(matrix)\n    if isempty(matrix)\n        return []\n    end\n\n    n, m = size(matrix)\n    tlx, tly, brx, bry = Int[], Int[], Int[], Int[]\n\n    # Build histogram heights\n    for i in 1:n\n        j = 1\n        while j <= m\n            if matrix[i, j] == 1\n                j += 1\n                continue\n            end\n            push!(tlx, j)\n            push!(tly, i)\n            while j <= m && matrix[i, j] == 0\n                j += 1\n            end\n            push!(brx, j - 1)\n            push!(bry, i)\n        end\n    end\n\n    return zip(tlx, tly, brx, bry)\nend\n\nfunction get_obstacles(lb, ub, h)\n    # lb_x1 = -3.5, ub_x1 = 3.5, lb_x2 = -2.6, ub_x2 = 2.6, h = 0.1\n    lb_x1, lb_x2, lb_x3 = lb\n    ub_x1, ub_x2, ub_x3 = ub\n\n    # Define the obstacles\n    x1 = range(lb_x1; stop = ub_x1, step = h)\n    x2 = range(lb_x2; stop = ub_x2, step = h)\n    steps1, steps2 = length(x1), length(x2)\n\n    X1 = x1' .* ones(steps2)\n    X2 = ones(steps1)' .* x2\n\n    Z1 = (X1 .^ 2 .- X2 .^ 2) .<= 4\n    Z2 = (4 .* X2 .^ 2 .- X1 .^ 2) .<= 16\n\n    # Find the upper and lower bounds of X1 and X2 for the obstacle\n    grid = Z1 .& Z2\n\n    return [\n        MOI.HyperRectangle([x1[x1lb], x2[x2lb]], [x1[x1ub], x2[x2ub]]) for\n        (x1lb, x2lb, x1ub, x2ub) in extract_rectangles(grid)\n    ]\nend\n\nobstacles = get_obstacles(x_low, x_upp, hx)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Function to add rectangular obstacle avoidance constraints","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"for obstacle in obstacles\n    @constraint(model, x[1:2] ∉ obstacle)\nend","category":"page"},{"location":"generated/Unicycle robot/#Definition-of-the-abstraction","page":"Unicycle robot","title":"Definition of the abstraction","text":"","category":"section"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We define the growth bound function of f:","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"function growth_bound(r, u, _)\n    β = u[1] * r[3]\n    return StaticArrays.SVector{3}(β, β, 0.0)\nend\nset_attribute(model, \"growthbound_map\", growth_bound)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We define the inverse system map:","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"function sys_inv(x, u, _)\n    return StaticArrays.SVector{3}(\n        x[1] - u[1] * cos(x[3] - u[2]),\n        x[2] - u[1] * sin(x[3] - u[2]),\n        x[3] - u[2],\n    )\nend\nset_attribute(model, \"sys_inv_map\", sys_inv)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Definition of the grid of the state-space on which the abstraction is based (origin x0 and state-space discretization h):","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"x0 = SVector(0.0, 0.0, 0.0);\nh = SVector(hx, hx, 0.2);\nset_attribute(model, \"state_grid\", Dionysos.Domain.GridFree(x0, h))","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Definition of the grid of the input-space on which the abstraction is based (origin u0 and input-space discretization h):","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"u0 = SVector(1.1, 0.0);\nh = SVector(0.3, 0.3);\nset_attribute(model, \"input_grid\", Dionysos.Domain.GridFree(u0, h))\n\noptimize!(model)","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Get the results","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"abstract_system = get_attribute(model, \"abstract_system\");\nabstract_problem = get_attribute(model, \"abstract_problem\");\nabstract_controller = get_attribute(model, \"abstract_controller\");\nconcrete_controller = get_attribute(model, \"concrete_controller\")\nconcrete_problem = get_attribute(model, \"concrete_problem\");\nconcrete_system = concrete_problem.system","category":"page"},{"location":"generated/Unicycle robot/#Trajectory-display","page":"Unicycle robot","title":"Trajectory display","text":"","category":"section"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We choose a stopping criterion reached and the maximal number of steps nsteps for the sampled system, i.e. the total elapsed time: nstep*tstep as well as the true initial state x0 which is contained in the initial state-space _I_ defined previously.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"nstep = 100\nfunction reached(x)\n    if x ∈ concrete_problem.target_set\n        return true\n    else\n        return false\n    end\nend\n\ncontrol_trajectory = Dionysos.System.get_closed_loop_trajectory(\n    get_attribute(model, \"discretized_system\"),\n    concrete_controller,\n    x_initial,\n    nstep;\n    stopping = reached,\n)\n\nusing Plots","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Here we display the coordinate projection on the two first components of the state space along the trajectory.","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"fig = plot(; aspect_ratio = :equal);\nnothing #hide","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We display the concrete domain","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"plot!(concrete_system.X; color = :yellow, opacity = 0.5);\nnothing #hide","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We display the abstract domain","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"plot!(abstract_system.Xdom; color = :blue, opacity = 0.5);\nnothing #hide","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We display the concrete specifications","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"plot!(concrete_problem.initial_set; color = :green, opacity = 0.2);\nplot!(concrete_problem.target_set; dims = [1, 2], color = :red, opacity = 0.2);\nnothing #hide","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We display the abstract specifications","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"plot!(\n    Dionysos.Symbolic.get_domain_from_symbols(\n        abstract_system,\n        abstract_problem.initial_set,\n    );\n    color = :green,\n);\nplot!(\n    Dionysos.Symbolic.get_domain_from_symbols(abstract_system, abstract_problem.target_set);\n    color = :red,\n);\nnothing #hide","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"We display the concrete trajectory","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"plot!(control_trajectory; ms = 0.5)","category":"page"},{"location":"generated/Unicycle robot/#References","page":"Unicycle robot","title":"References","text":"","category":"section"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"Z. Azaki, A. Girard and S. Olaru, \"Predictive and Symbolic Control: Performance and Safety for Non-linear Systems,\" in IFAC-PapersOnLine, 2022, vol. 55, no 16, pp. 290-295..","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"","category":"page"},{"location":"generated/Unicycle robot/","page":"Unicycle robot","title":"Unicycle robot","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"EditURL = \"../examples/utils/Ellipsoids.jl\"","category":"page"},{"location":"generated/Ellipsoids/#Ellipsoids","page":"Ellipsoids","title":"Ellipsoids","text":"","category":"section"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"In this file, we will visit the basic features provided by Dionysos for manipulating ellipsoids:","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"inclusion\nintersection","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"First, let us import a few packages that are necessary to run this example.","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"using Dionysos\nusing StaticArrays\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"The main package Dionysos provides most important data structures that we will need.","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"const DI = Dionysos\nconst UT = DI.Utils","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"We define a plotting functions","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"function plot_config!(fig, El0, El, Elnew)\n    if Elnew ∈ El0\n        plot!(fig, El0; color = :red, label = \"El0\")\n        plot!(fig, Elnew; color = :green, label = \"Elnew\")\n    else\n        plot!(fig, Elnew; color = :green, label = \"Elnew\")\n        plot!(fig, El0; color = :red, label = \"El0\")\n    end\n    return plot!(fig, El; color = :blue, label = \"El\", show = true)\nend\n\nfunction analyze(fig1, fig2, i)\n    El0 = E0L[i]\n    Elnew = UT.scale_for_inclusion_contact_point(El0, El)\n    plot_config!(fig1, El0, El, Elnew)\n    println(El0 ∈ El ? \"El0 ∈ El\" : \"El0 ∉ El\")\n\n    Elnew = UT.scale_for_noninclusion_contact_point(El0, El)\n    plot_config!(fig2, El0, El, Elnew)\n    return println(UT.is_intersected(El0, El) ? \"El0 ∩ El ≠ ∅\" : \"El0 ∩ El = ∅\")\nend","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"We define some ellipsoids","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"c = [1.5; 1.5]\nP = [\n    4.0 0.5\n    0.5 6.0\n]\nEl = UT.Ellipsoid(P, c)\n\nP0 = [\n    0.4 -0.1\n    -0.1 0.5\n]\nvals = [4.1, 3.32, 2.8, 2.4]\nE0L = [UT.Ellipsoid(P0, [c0x; c0x - 0.2]) for c0x in vals]","category":"page"},{"location":"generated/Ellipsoids/#Case-1:-non-intersection","page":"Ellipsoids","title":"Case 1: non intersection","text":"","category":"section"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"fig1_1 = plot(; aspect_ratio = :equal);\nfig1_2 = plot(; aspect_ratio = :equal);\nanalyze(fig1_1, fig1_2, 1)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig1_1)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig1_2)","category":"page"},{"location":"generated/Ellipsoids/#Case-2:-non-intersection","page":"Ellipsoids","title":"Case 2: non intersection","text":"","category":"section"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"fig2_1 = plot(; aspect_ratio = :equal);\nfig2_2 = plot(; aspect_ratio = :equal);\nanalyze(fig2_1, fig2_2, 2)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig2_1)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig2_2)","category":"page"},{"location":"generated/Ellipsoids/#Case-3:-intersection,-non-inclusion","page":"Ellipsoids","title":"Case 3: intersection, non inclusion","text":"","category":"section"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"fig3_1 = plot(; aspect_ratio = :equal);\nfig3_2 = plot(; aspect_ratio = :equal);\nanalyze(fig3_1, fig3_2, 3)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig3_1)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig3_2)","category":"page"},{"location":"generated/Ellipsoids/#Case-4:-inclusion","page":"Ellipsoids","title":"Case 4: inclusion","text":"","category":"section"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"fig4_1 = plot(; aspect_ratio = :equal);\nfig4_2 = plot(; aspect_ratio = :equal);\nanalyze(fig4_1, fig4_2, 4)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig4_1)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"plot!(fig4_2)","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"","category":"page"},{"location":"generated/Ellipsoids/","page":"Ellipsoids","title":"Ellipsoids","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"EditURL = \"../examples/utils/Grid.jl\"","category":"page"},{"location":"generated/Grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"In this file, we will show the different partition of the state space implemented","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"classical grid (composed of regular hyperrectangles)\ndeformed grid\nnested classical grid\nellipsoidal partition based on a grid","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"First, let us import a few packages that are necessary to run this example.","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"using Dionysos\nusing StaticArrays\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"The main package Dionysos provides most important data structures that we will need.","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"const DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain","category":"page"},{"location":"generated/Grid/#Classical-grid-(composed-of-regular-hyperrectangles)","page":"Grid","title":"Classical grid (composed of regular hyperrectangles)","text":"","category":"section"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"x0 = SVector(0.0, 0.0)\nh = SVector(1.0 / 5, 1.0 / 5)\ngrid = DO.GridFree(x0, h)\nrectX = UT.HyperRectangle(SVector(-2, -2), SVector(2, 2));\ndomainX = DO.DomainList(grid)\nDO.add_set!(domainX, rectX, DO.INNER)\nplot(; aspect_ratio = :equal);\nplot!(domainX)","category":"page"},{"location":"generated/Grid/#Deformed-grid","page":"Grid","title":"Deformed grid","text":"","category":"section"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"We define some invertible transformation (with their inverse)","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"function f1(x)\n    return x\nend\nfunction fi1(x)\n    return x\nend\nfunction f2(x)\n    return SVector(x[2] + sin(x[1]), x[1])\nend\nfunction fi2(x)\n    return SVector(x[2], x[1] - sin(x[2]))\nend\nfunction f3(x)\n    return SVector(x[1] * cos(x[2]), x[1] * sin(x[2]))\nend\nfunction fi3(x)\n    return SVector(sqrt(x[1] * x[1] + x[2] * x[2]), atan(x[2], x[1]))\nend\nfunction rotate(x, θ)\n    R = @SMatrix [\n        cos(θ) -sin(θ)\n        sin(θ) cos(θ)\n    ]\n    return R * x\nend\nfunction build_f_rotation(θ; c = SVector(0.0, 0.0))\n    function f(x)\n        return rotate(x - c, θ) + c\n    end\n    function fi(x)\n        return rotate(x - c, -θ) + c\n    end\n    return f, fi\nend\n\nfunction plot_deformed_grid_with_DomainList(f, fi)\n    X = UT.HyperRectangle(SVector(0.0, 0.0), SVector(30.0, 2 * π))\n    grid = DO.GridFree(SVector(0.0, 0.0), SVector(3.0, 0.3))\n    Dgrid = DO.DeformedGrid(grid, f, fi)\n    dom = DO.DomainList(Dgrid)\n    DO.add_set!(dom, X, DO.INNER)\n    plot(; aspect_ratio = :equal)\n    return plot!(dom; show = true)\nend\n\nfunction plot_deformed_grid_with_GeneralDomain(f, fi)\n    X = UT.HyperRectangle(SVector(0.0, 0.0), SVector(30.0, 2 * π))\n    obstacle = UT.HyperRectangle(SVector(10.0, 10.0), SVector(15.0, 15.0))\n    hx = [3.0, 0.3]\n    d = DO.RectangularObstacles(X, [obstacle])\n    dom = DO.GeneralDomainList(hx; elems = d, f = f, fi = fi, fit = true)\n    plot(; aspect_ratio = :equal)\n    return plot!(dom; show = true)\nend","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"Display some deformed Grids","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"plot_deformed_grid_with_DomainList(f2, fi2)\nplot_deformed_grid_with_GeneralDomain(f2, fi2)","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"plot_deformed_grid_with_DomainList(f2, fi2)\nplot_deformed_grid_with_GeneralDomain(f2, fi2)","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"plot_deformed_grid_with_DomainList(f3, fi3)\nplot_deformed_grid_with_GeneralDomain(f3, fi3)","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"f, fi = build_f_rotation(π / 3.0)\nplot_deformed_grid_with_DomainList(f, fi)","category":"page"},{"location":"generated/Grid/#Nested-classical-grid","page":"Grid","title":"Nested classical grid","text":"","category":"section"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"X = UT.HyperRectangle(SVector(0.0, 0.0), SVector(30.0, 30.0))\nobstacle = UT.HyperRectangle(SVector(15.0, 15.0), SVector(20.0, 20.0))\nhx = [3.0, 1.0] * 2.0\nperiodic = Int[1]\nperiods = [30.0, 30.0]\nT0 = [0.0, 0.0]\nd = DO.RectangularObstacles(X, [obstacle])\ndom = DO.GeneralDomainList(\n    hx;\n    elems = d,\n    periodic = periodic,\n    periods = periods,\n    T0 = T0,\n    fit = true,\n)\nNdomain = DO.NestedDomain(dom)\nDO.cut_pos!(Ndomain, (2, 2), 1)\nDO.cut_pos!(Ndomain, (2, 3), 1)\nDO.cut_pos!(Ndomain, (4, 4), 2)\n\nfig = plot(; aspect_ratio = :equal, legend = false);\nplot!(Ndomain)","category":"page"},{"location":"generated/Grid/#Ellipsoidal-partition-based-on-a-grid","page":"Grid","title":"Ellipsoidal partition based on a grid","text":"","category":"section"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"x0 = SVector(0.0, 0.0)\nn_step = 2\nh = SVector(1.0 / n_step, 1.0 / n_step)\nP = 0.5 * diagm((h ./ 2) .^ (-2))\nrectX = UT.HyperRectangle(SVector(-2, -2), SVector(2, 2))\n\ngrid = DO.GridEllipsoidalRectangular(x0, h, P, rectX)\ndomain = DO.DomainList(grid)\nDO.add_set!(domain, grid.rect, DO.OUTER)\nplot(; aspect_ratio = :equal);\nplot!(domain)","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"","category":"page"},{"location":"generated/Grid/","page":"Grid","title":"Grid","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/abstraction-based-control/#Abstraction-based-control","page":"Abstraction-based control","title":"Abstraction-based control","text":"","category":"section"},{"location":"manual/abstraction-based-control/","page":"Abstraction-based control","title":"Abstraction-based control","text":"Given a mathematical description of the system dynamics and the specifications describing the desired closed-loop behavior of the system, abstraction-based control techniques involve synthesizing a correct-by-construction controller through a systematic three-step procedure. First, both the original system and the specifications are transposed into an abstract domain, resulting in an abstract system and corresponding abstract specifications. We refer to the original system as the concrete system as opposed to the abstract system. Next, an abstract controller is synthesized to solve this abstract control problem. Finally, in the third step, called concretization as opposed to abstraction, a controller for the original control problem is derived from the abstract controller.","category":"page"},{"location":"manual/abstraction-based-control/","page":"Abstraction-based control","title":"Abstraction-based control","text":"In practice, the abstract domain is constructed by discretizing the concrete state space of the concrete system into subsets (called cells). The value of this approach lies in the substitution of the concrete system (often a system with an infinite number of states) with a finite state system, which makes it possible to leverage powerful control tools from the graph-theoretic field, such as Dijkstra or the A-star algorithm. This three steps procedure is illustrated on the following figure.","category":"page"},{"location":"manual/abstraction-based-control/","page":"Abstraction-based control","title":"Abstraction-based control","text":"(Image: Abstraction-based control.)","category":"page"},{"location":"manual/abstraction-based-control/","page":"Abstraction-based control","title":"Abstraction-based control","text":"Although this approach offers a safety-critical framework, it suffers from the curse of dimensionality due to the exponential growth of the number of states with respect to the dimension. In order to render these techniques practical, it is necessary to construct smart abstractions, i.e., they differ from classical techniques in that the partitioning is designed smartly, using optimization-based design techniques, and computed iteratively, unlike the classical approach which uses an a priori defined approach, sub-optimal and subject to the curse of dimensionality. To this end, we propose solvers called lazy solvers (i.e. postponing heavier numerical operations) that co-design the abstraction and the controller to reduce the computed part of the abstraction.","category":"page"},{"location":"reference/Utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"reference/Utils/","page":"Utils","title":"Utils","text":"This folder contains all the auxiliary functions needed.","category":"page"},{"location":"reference/Utils/#Functions","page":"Utils","title":"Functions","text":"","category":"section"},{"location":"reference/Utils/","page":"Utils","title":"Utils","text":"Dionysos.Utils.QuadraticStateControlFunction ","category":"page"},{"location":"reference/Utils/#Dionysos.Utils.QuadraticStateControlFunction","page":"Utils","title":"Dionysos.Utils.QuadraticStateControlFunction","text":"QuadraticStateControlFunction{T, MT<:AbstractMatrix{T}}\n\nQuadratic function on state and input defined as x'Qx + u'Ru + 2x'Nu + 2x'q + 2u'r + v \n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Search","page":"Utils","title":"Search","text":"","category":"section"},{"location":"reference/Utils/","page":"Utils","title":"Utils","text":"Dionysos.Utils.expand\nDionysos.Utils.path_cost\nDionysos.Utils.breadth_first_graph_search\nDionysos.Utils.depth_first_graph_search\nDionysos.Utils.best_first_graph_search\nDionysos.Utils.path\nDionysos.Utils.AbstractQueue\nDionysos.Utils.MyStack\nDionysos.Utils.tree_search\nDionysos.Utils.goal_test\nDionysos.Utils.astar_graph_search\nDionysos.Utils.astar_tree_search\nDionysos.Utils.breadth_first_tree_search\nDionysos.Utils.graph_search\nDionysos.Utils.best_first_tree_search\nDionysos.Utils.successor\nDionysos.Utils.Node\nDionysos.Utils.depth_first_tree_search\nDionysos.Utils.MyPriorityQueue\nDionysos.Utils.FIFOQueue\nDionysos.Utils.SearchProblem\nDionysos.Utils.BranchAndBound.Abstract_BB_Problem\nDionysos.Utils.get_min_bounding_box\nDionysos.Utils.NodeT\nDionysos.Utils.collect_children\nDionysos.Utils.RRT\nDionysos.Utils.add_node!\nDionysos.Utils.propagate_cost_to_leaves\nDionysos.Utils.get_path\nDionysos.Utils.Tree","category":"page"},{"location":"reference/Utils/#Dionysos.Utils.expand","page":"Utils","title":"Dionysos.Utils.expand","text":"Yield the nodes reachable from this node.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.path_cost","page":"Utils","title":"Dionysos.Utils.path_cost","text":"Return the cost of a solution path that arrives at state2 from state1 via action, assuming cost c to get up to state1. If the problem is such that the path doesn't matter, this function will only look at state2.  If the path does matter, it will consider c and maybe state1 and action. The default method costs 1 for every step in the path.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.breadth_first_graph_search","page":"Utils","title":"Dionysos.Utils.breadth_first_graph_search","text":"Search the shallowest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.depth_first_graph_search","page":"Utils","title":"Dionysos.Utils.depth_first_graph_search","text":"Search the deepest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.best_first_graph_search","page":"Utils","title":"Dionysos.Utils.best_first_graph_search","text":"Search the nodes with the lowest f scores first. You specify the function f(node) that you want to minimize; for example, if f is a heuristic estimate to the goal, then we have greedy best first search; if f is node.depth then we have depth-first search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.path","page":"Utils","title":"Dionysos.Utils.path","text":"Create a list of nodes from the root to this node.\n\n\n\n\n\nCreate a list of nodes from the root to this node.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.AbstractQueue","page":"Utils","title":"Dionysos.Utils.AbstractQueue","text":"AbstractQueue is an abstract type.     There are three types:     MyStack(): A Last In First Out Queue.     FIFOQueue(): A First In First Out Queue.     MyPriorityQueue(f,ext): Queue where items are sorted by f, (default <). Each type supports the following methods and functions:     append!(q,item)  – add an item to the queue     extend!(q,items) – equivalent to: for item in items: append(q,item)     pop!(q)          – return the top item from the queue     length(q)        – number of items in q\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.MyStack","page":"Utils","title":"Dionysos.Utils.MyStack","text":"Return an empty list, suitable as a Last-In-First-Out Queue.\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.tree_search","page":"Utils","title":"Dionysos.Utils.tree_search","text":"Search through the successors of a problem to find a goal. The argument fringe should be an empty queue. Don't worry about repeated paths to a state.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.goal_test","page":"Utils","title":"Dionysos.Utils.goal_test","text":"Return True if the state is a goal. The default method compares the state to P.goal, as specified in the constructor. Implement this method if checking against a single goal is not enough.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.astar_graph_search","page":"Utils","title":"Dionysos.Utils.astar_graph_search","text":"A* search is best-first graph search with f(n) = g(n)+h(n). You need to specify the h function when you call astar_search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.astar_tree_search","page":"Utils","title":"Dionysos.Utils.astar_tree_search","text":"A* search is best-first graph search with f(n) = g(n)+h(n). You need to specify the h function when you call astar_search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.breadth_first_tree_search","page":"Utils","title":"Dionysos.Utils.breadth_first_tree_search","text":"Search the shallowest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.graph_search","page":"Utils","title":"Dionysos.Utils.graph_search","text":"Search through the successors of a problem to find a goal. The argument fringe should be an empty queue. If two paths reach a state, only use the best one.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.best_first_tree_search","page":"Utils","title":"Dionysos.Utils.best_first_tree_search","text":"Search the nodes with the lowest f scores first. You specify the function f(node) that you want to minimize; for example, if f is a heuristic estimate to the goal, then we have greedy best first search; if f is node.depth then we have depth-first search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.successor","page":"Utils","title":"Dionysos.Utils.successor","text":"Given a state, return a sequence of (action, state) pairs reachable from this state. If there are many successors, consider an iterator that yields the successors one at a time, rather than building them all at once.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.Node","page":"Utils","title":"Dionysos.Utils.Node","text":"A node in a search tree. Contains a pointer to the parent (the node that this is a successor of) and to the actual state for this node. Note that if a state is arrived at by two paths, then there are two nodes with the same state. Also includes the action that got us to this state, and the total pathcost (also known as g) to reach the node. Other functions may add an f and h value; see bestfirstgraphsearch and astar_search for an explanation of how the f and h values are handled.\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.depth_first_tree_search","page":"Utils","title":"Dionysos.Utils.depth_first_tree_search","text":"Search the deepest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.MyPriorityQueue","page":"Utils","title":"Dionysos.Utils.MyPriorityQueue","text":"A queue in which the minimum (or maximum) element (as determined by f) is returned first. Keys of type T and priorities of type V.\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.FIFOQueue","page":"Utils","title":"Dionysos.Utils.FIFOQueue","text":"A First-In-First-Out Queue.\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.SearchProblem","page":"Utils","title":"Dionysos.Utils.SearchProblem","text":"SearchProblem\n\nFields\n\n- `initial`  -- initial state of type `S` or a list of initial state of type `S`.\n- `goal`     -- possibly a goal state of type 'Union{Nothing,S}''.\n\nExample\n\nstruct Problem{S} <: SearchProblem{S}\n    initial::Union{S,Vector{S}}\n    goal::Union{Nothing,S}\nend\nThe constructor specifies the initial state, and possibly a goal\nstate, if there is a unique goal.\nfunction Problem(initial::S; goal=nothing) where S\n    return Problem{S}(initial,goal)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.BranchAndBound.Abstract_BB_Problem","page":"Utils","title":"Dionysos.Utils.BranchAndBound.Abstract_BB_Problem","text":"Abstract_BB_Problem #abstract branch and bound problem\n\nSould implement the methods below\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.get_min_bounding_box","page":"Utils","title":"Dionysos.Utils.get_min_bounding_box","text":"get_min_bounding_box(elli, optimizer)\n\nFinds the minimum bounding box containing the ellipsoid {(x-c)'P(x-c) < 1}. \n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.NodeT","page":"Utils","title":"Dionysos.Utils.NodeT","text":"cost: cost to reach its parent\n\n\n\n\n\n","category":"type"},{"location":"reference/Utils/#Dionysos.Utils.collect_children","page":"Utils","title":"Dionysos.Utils.collect_children","text":"Return a list with all the children of node\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.RRT","page":"Utils","title":"Dionysos.Utils.RRT","text":"Basic generic RRT algorihtm\nSI : initial state (this will be the root of the tree) ;\nSF : target state that we try to reach ;\ndistance : function that defines a metric between the states ;\nrand_state : function that returns a random candidate state ;\nnew_conf : function that returns a reachable state, with the action and the cost ;\nkeep : function to filter the node that we want to add during an iteration;\nstop_crit : stop criteria ;\nRRTstar : boolean to use RRT* ;\ncompute_transition : to compute transition between to given state (if RRTstar is true).\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.add_node!","page":"Utils","title":"Dionysos.Utils.add_node!","text":"add a node as a leave\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.propagate_cost_to_leaves","page":"Utils","title":"Dionysos.Utils.propagate_cost_to_leaves","text":"assuming that the path_cost of a node has changed (and its depth),  we should propagate the new cost to its children\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.get_path","page":"Utils","title":"Dionysos.Utils.get_path","text":"return the path from node to the root of the tree\n\n\n\n\n\n","category":"function"},{"location":"reference/Utils/#Dionysos.Utils.Tree","page":"Utils","title":"Dionysos.Utils.Tree","text":"Tree structure with\n\ncost for transitions (the cost function a non-negative function);\nan underlying metric between the states that are encapsulated in the nodes of the tree\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Domain","page":"Domain","title":"Domain","text":"","category":"section"},{"location":"reference/Domain/","page":"Domain","title":"Domain","text":"This folder contains structures that are used to encode different kinds of concrete and abstract domains.","category":"page"},{"location":"reference/Domain/#Concrete-continuous-domains","page":"Domain","title":"Concrete continuous domains","text":"","category":"section"},{"location":"reference/Domain/","page":"Domain","title":"Domain","text":"Dionysos.Domain.ContinuousUnboundedDomain\nDionysos.Domain.ContinuousBoundedDomain\nDionysos.Domain.ContinuousBoundedEllipsoidDomain\nDionysos.Domain.RectangularObstacles","category":"page"},{"location":"reference/Domain/#Dionysos.Domain.ContinuousUnboundedDomain","page":"Domain","title":"Dionysos.Domain.ContinuousUnboundedDomain","text":"ContinuousUnboundedDomain{N,T}\n\nStruct for a basic unbounded continuous domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.ContinuousBoundedDomain","page":"Domain","title":"Dionysos.Domain.ContinuousBoundedDomain","text":"ContinuousBoundedDomain{N,T,B}\n\nStruct for a basic bounded continuous domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.ContinuousBoundedEllipsoidDomain","page":"Domain","title":"Dionysos.Domain.ContinuousBoundedEllipsoidDomain","text":"ContinuousBoundedEllipsoidDomain{N,T,S<:Grid{N,T}}\n\nStruct for a basic bounded continuous domain formed by a finite number of ellipsoids.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.RectangularObstacles","page":"Domain","title":"Dionysos.Domain.RectangularObstacles","text":"RectangularObstacles{VT} <: AbstractSet{VT}\n\nStruct for a rectangular domain with rectangular obstacles.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Abstract-domains","page":"Domain","title":"Abstract domains","text":"","category":"section"},{"location":"reference/Domain/","page":"Domain","title":"Domain","text":"Dionysos.Domain.DomainList\nDionysos.Domain.GeneralDomainList\nDionysos.Domain.GridRectangular\nDionysos.Domain.GridFree\nDionysos.Domain.GridEllipsoidalRectangular","category":"page"},{"location":"reference/Domain/#Dionysos.Domain.DomainList","page":"Domain","title":"Dionysos.Domain.DomainList","text":"DomainList{N,T,S<:Grid{N,T}}\n\nStruct for a basic domain based on a Grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.GeneralDomainList","page":"Domain","title":"Dionysos.Domain.GeneralDomainList","text":"GeneralDomainList{N,E<:AbstractSet{NTuple{N,Int}},T,S<:Grid{N,T},F} <: DomainType{N,T}\n\nStruct for a rectangular domain with rectangular obstacles.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.GridRectangular","page":"Domain","title":"Dionysos.Domain.GridRectangular","text":"GridRectangular{N,T} <: Grid{N,T}\n\nUniform grid on rectangular space rect, centered at orig and with steps set by the vector h.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.GridFree","page":"Domain","title":"Dionysos.Domain.GridFree","text":"GridFree{N,T} <: Grid{N,T}\n\nUniform grid on unbounded space, centered at orig and with steps set by the vector h.\n\n\n\n\n\n","category":"type"},{"location":"reference/Domain/#Dionysos.Domain.GridEllipsoidalRectangular","page":"Domain","title":"Dionysos.Domain.GridEllipsoidalRectangular","text":"GridEllipsoidalRectangular{N,T} <: Grid{N,T}\n\nUniform grid on rectangular space rect, centered at orig and with steps set by the vector h. Cells are (possibly overlapping) ellipsoids defined at each grid point c as (x-c)'P(x-c) ≤ 1.\n\n\n\n\n\n","category":"type"},{"location":"developers/setup/#Set-up","page":"Set up","title":"Set up","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"This guide shows you what to do when you start developing for Dionysos.","category":"page"},{"location":"developers/setup/#Installations","page":"Set up","title":"Installations","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"Start by installing Julia, VSCode and the Julia extension of VSCode as detailed here. Now, install Git by following https://git-scm.com/book/en/v2/Getting-Started-Installing-Git.","category":"page"},{"location":"developers/setup/#Launching-the-prompts","page":"Set up","title":"Launching the prompts","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"For every step, we show both how to do it from Visual Studio Code (VSCode) or from the Julia REPL or Git bash.","category":"page"},{"location":"developers/setup/#Start-the-Julia-REPL","page":"Set up","title":"Start the Julia REPL","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"To start a Julia REPL, type Shift+Ctrl+P and then Julia: Start REPL. You should have installed Julia and the Julia VSCode extension as detailed in Installations for this to work. You should see a prompt julia> appearing. We always show the prompt you should see for every command as well as the output, don't copy-paste the prompt nor the output.","category":"page"},{"location":"developers/setup/#Start-Julia-Pkg-prompt","page":"Set up","title":"Start Julia Pkg prompt","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"First Start the Julia REPL. Then, by pressing the ] character you will see a (@v1.8) pkg> prompt appearing (if you are using the global environment). By pressing the backspace you will get back to the julia> prompt. We always show the prompt you should see for every command as well as the output, don't copy-paste the prompt nor the output.","category":"page"},{"location":"developers/setup/#Start-Git-bash","page":"Set up","title":"Start Git bash","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"To start Git bash, click on the top menu of VSCode on \"View\" then \"Terminal\". On the bottom right, click on the down arrow at the right of the \"+\" and then on \"Git bash\" on the dropdown menu that appears. You should have installed Julia and the Julia VSCode extension as detailed in Installations for this to work. You should see a prompt $ appearing. We always show the prompt you should see for every command as well as the output, don't copy-paste the prompt nor the output.","category":"page"},{"location":"developers/setup/#Cloning-Dionysos","page":"Set up","title":"Cloning Dionysos","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"The purpose of this is to clone Dionysos at the location ~/.julia/dev/Dionysos where ~ is your home folder.","category":"page"},{"location":"developers/setup/#VSCode","page":"Set up","title":"VSCode","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"Switch to Source Control by pressing Ctrl+Shift+G then on the three horizontal dots on the top right of the left pane then \"clone\" then write https://github.com/dionysos-dev/Dionysos.jl.git and then select the folder .julia/dev. Then rename the created folder ~/.julia/dev/Dionysos into ~/.julia/dev/Dionysos using your file manager.","category":"page"},{"location":"developers/setup/#Julia-REPL","page":"Set up","title":"Julia REPL","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"See Start the Julia REPL.","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"julia> using Pkg; Pkg.develop(url=\"https://github.com/dionysos-dev/Dionysos.jl.git\")","category":"page"},{"location":"developers/setup/#Julia-Pkg-prompt","page":"Set up","title":"Julia Pkg prompt","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"See Start Julia Pkg prompt.","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"(@v1.8) pkg> dev https://github.com/dionysos-dev/Dionysos.jl.git","category":"page"},{"location":"developers/setup/#Install-the-Revise.jl-and-JuliaFormatter.jl-packages","page":"Set up","title":"Install the Revise.jl and JuliaFormatter.jl packages","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"Revise.jl reduces the need to restart your Julia REPL when you make changes in the source code. JuliaFormatter.jl allows to format your code following the rules stated in .JuliaFormatter.toml.","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"We install these two packages in the global environment so that it is available from all the environments.","category":"page"},{"location":"developers/setup/#Julia-REPL-2","page":"Set up","title":"Julia REPL","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"See Start the Julia REPL.","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"julia> using Pkg; Pkg.add(\"Revise\"); Pkg.add(\"JuliaFormatter\")","category":"page"},{"location":"developers/setup/#Julia-Pkg-prompt-2","page":"Set up","title":"Julia Pkg prompt","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"See Start Julia Pkg prompt.","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"(@v1.8) pkg> add Revise\n(@v1.8) pkg> add JuliaFormatter","category":"page"},{"location":"developers/setup/#Open-Dionysos","page":"Set up","title":"Open Dionysos","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"In VSCode, do File/Open Folder.../ and select the folder .julia/dev/Dionysos inside your home directory. Before doing any changes, make sure to Switch to the master branch and update it; see Workflow.","category":"page"},{"location":"developers/setup/#Build-the-documentation","page":"Set up","title":"Build the documentation","text":"","category":"section"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"To build the documentation, start by activating the documentation environment and using the Dionysos version in development. Start by ] to enter the package environment:","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"(@v1.7) pkg> activate docs\n  Activating project at `~/.julia/dev/Dionysos/docs`\n\n(docs) pkg> dev .\n   Resolving package versions...\n  No Changes to `~/.julia/dev/Dionysos/docs/Project.toml`\n  No Changes to `~/.julia/dev/Dionysos/docs/Manifest.toml`","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"Once in a while you can also update with","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"(docs) pkg> up\n    Updating registry at `~/.julia/registries/General`\n    Updating git-repo `https://github.com/JuliaRegistries/General.git`\n  No Changes to `~/.julia/dev/Dionysos/docs/Project.toml`\n  No Changes to `~/.julia/dev/Dionysos/docs/Manifest.toml`","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"If you plan to change the documentation, it might be a good idea to use Revise (see Install the Revise.jl and JuliaFormatter.jl packages):","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"julia> using Revise","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"If you don't plan to test the examples, comment out the Literate part in docs/make.jl:","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":" 20 # for example in EXAMPLES_SOLVERS\n 21 #     literate_actions(joinpath(EXAMPLES_SOLVERS_DIR, example), OUTPUT_DIR)\n 22 # end\n 23 # for example in EXAMPLES_UTILS\n 24 #     literate_actions(joinpath(EXAMPLES_UTILS_DIR, example), OUTPUT_DIR)\n 25 # end\n 26 # literate_actions(joinpath(@__DIR__, \"src\", \"Getting Started.jl\"), OUTPUT_DIR)","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"This will speed up building the documentation quite a lot.","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"Now, build the documentation with:","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"julia> include(\"docs/make.jl\")","category":"page"},{"location":"developers/setup/","page":"Set up","title":"Set up","text":"To view it, open the file docs/build/index.html with your web browser.","category":"page"},{"location":"reference/System/#System","page":"System","title":"System","text":"","category":"section"},{"location":"reference/System/","page":"System","title":"System","text":"This folder contains different ways to define systems, for instance to encode a controller.","category":"page"},{"location":"reference/System/#Control-system","page":"System","title":"Control system","text":"","category":"section"},{"location":"reference/System/","page":"System","title":"System","text":"Each control system should be implemented as a ControlSystem.","category":"page"},{"location":"reference/System/","page":"System","title":"System","text":"Dionysos.System.ControlSystem","category":"page"},{"location":"reference/System/#Dionysos.System.ControlSystem","page":"System","title":"Dionysos.System.ControlSystem","text":"The structure\n\nControlSystem{N, T}\n\nis the abstract type that defines a control system.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/","page":"System","title":"System","text":"So far, we have implemented a few examples of control systems: ","category":"page"},{"location":"reference/System/","page":"System","title":"System","text":"Dionysos.System.SimpleSystem\nDionysos.System.ControlSystemGrowth\nDionysos.System.ControlSystemLinearized\nDionysos.System.EllipsoidalAffineApproximatedSystem","category":"page"},{"location":"reference/System/#Dionysos.System.SimpleSystem","page":"System","title":"Dionysos.System.SimpleSystem","text":"SimpleSystem{N, T, F <: Function, F2} <: ControlSystem{N, T}\n\nis one implementation of the ControlSystem type. \n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.ControlSystemGrowth","page":"System","title":"Dionysos.System.ControlSystemGrowth","text":"ControlSystemGrowth{N, T, F1 <: Function, F2 <: Function, F3 <: Function} <: ControlSystem{N, T}\n\nis one implementation of the ControlSystem type for which we have a growth bound function.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.ControlSystemLinearized","page":"System","title":"Dionysos.System.ControlSystemLinearized","text":"ControlSystemLinearized{N, T, F1 <: Function, F2 <: Function, F3 <: Function, F4 <: Function, } <: ControlSystem{N, T}\n\nis one implementation of the ControlSystem type for which we have linearized the system map.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.EllipsoidalAffineApproximatedSystem","page":"System","title":"Dionysos.System.EllipsoidalAffineApproximatedSystem","text":"EllipsoidalAffineApproximatedSystem{}\n\nis a system whose dynamics is a noisy constrained affine control discrete system whose cells are ellipsoids, with a bound on the Lipschitz constant.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Controller","page":"System","title":"Controller","text":"","category":"section"},{"location":"reference/System/","page":"System","title":"System","text":"So far, the abstraction-based methods that we use define either piecewise-constant or piecewise-affine controllers.","category":"page"},{"location":"reference/System/","page":"System","title":"System","text":"Dionysos.System.ConstantController\nDionysos.System.AffineController","category":"page"},{"location":"reference/System/#Dionysos.System.ConstantController","page":"System","title":"Dionysos.System.ConstantController","text":"ConstantController{T, VT}\n\nencodes a constant state-dependent controller of the κ(x) = c.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.AffineController","page":"System","title":"Dionysos.System.AffineController","text":"AffineController{T, MT, VT1, VT2}\n\nencodes an affine state-dependent controller of the κ(x) = K*(x-c)+ℓ.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Trajectories","page":"System","title":"Trajectories","text":"","category":"section"},{"location":"reference/System/","page":"System","title":"System","text":"Dionysos.System.DiscreteTrajectory\nDionysos.System.ContinuousTrajectory\nDionysos.System.HybridTrajectory\nDionysos.System.Trajectory\nDionysos.System.Control_trajectory\nDionysos.System.Cost_control_trajectory","category":"page"},{"location":"reference/System/#Dionysos.System.DiscreteTrajectory","page":"System","title":"Dionysos.System.DiscreteTrajectory","text":"DiscreteTrajectory{Q, TT}\n\nq_0 is the starting mode and transitions is a sequence of discrete transitions in the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.ContinuousTrajectory","page":"System","title":"Dionysos.System.ContinuousTrajectory","text":"ContinuousTrajectory{T, XVT<:AbstractVector{T}, UVT<:AbstractVector{T}}\n\nx is a sequence of points in the state space and u is a sequence of points in the input space.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.HybridTrajectory","page":"System","title":"Dionysos.System.HybridTrajectory","text":"HybridTrajectory{T, TT, XVT <: AbstractVector{T}, UVT <: AbstractVector{T}}\n\ndiscrete is the discrete trajectory of type DiscreteTrajectory and  continuous is a the continuous trajectory of type ContinuousTrajectory.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.Trajectory","page":"System","title":"Dionysos.System.Trajectory","text":"Trajectory{T}\n\nprovides the sequence of some elements of a trajectory.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.Control_trajectory","page":"System","title":"Dionysos.System.Control_trajectory","text":"Control_trajectory{T1, T2}\n\nprovides the sequence of states and inputs of a trajectory.\n\n\n\n\n\n","category":"type"},{"location":"reference/System/#Dionysos.System.Cost_control_trajectory","page":"System","title":"Dionysos.System.Cost_control_trajectory","text":"Cost_control_trajectory{T1, T2, T3}\n\nprovides the sequence of states, inputs (via Control_trajectory) and costs of a trajectory.\n\n\n\n\n\n","category":"type"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"EditURL = \"../examples/solvers/Hierarchical-abstraction.jl\"","category":"page"},{"location":"generated/Hierarchical-abstraction/#Example:-Reachability-problem-solved-by-[Hierarchical-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"Hierarchical-abstraction","title":"Example: Reachability problem solved by Hierarchical abstraction.","text":"","category":"section"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"using StaticArrays, JuMP, Plots","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"At this point, we import Dionysos.","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"using Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst SY = DI.Symbolic\nconst PR = DI.Problem\nconst OP = DI.Optim\nconst AB = OP.Abstraction\n\ninclude(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"simple_problem.jl\"))\n\n# specific functions\nfunction post_image(abstract_system, concrete_system, xpos, u)\n    Xdom = abstract_system.Xdom\n    x = DO.get_coord_by_pos(Xdom.grid, xpos)\n    Fx = concrete_system.f_eval(x, u)\n    r = Xdom.grid.h / 2.0 + concrete_system.measnoise\n    Fr = r\n\n    rectI = DO.get_pos_lims_outer(Xdom.grid, UT.HyperRectangle(Fx .- Fr, Fx .+ Fr))\n    ypos_iter = Iterators.product(DO._ranges(rectI)...)\n    over_approx = []\n    allin = true\n    for ypos in ypos_iter\n        ypos = DO.set_in_period_pos(Xdom, ypos)\n        if !(ypos in Xdom)\n            allin = false\n            break\n        end\n        target = SY.get_state_by_xpos(abstract_system, ypos)[1]\n        push!(over_approx, target)\n    end\n    return allin ? over_approx : []\nend\n\nfunction pre_image(abstract_system, concrete_system, xpos, u)\n    grid = abstract_system.Xdom.grid\n    x = DO.get_coord_by_pos(grid, xpos)\n    potential = Int[]\n    x_prev = concrete_system.f_backward(x, u)\n    xpos_cell = DO.get_pos_by_coord(grid, x_prev)\n    n = 2\n    for i in (-n):n\n        for j in (-n):n\n            x_n = (xpos_cell[1] + i, xpos_cell[2] + j)\n            x_n = DO.set_in_period_pos(abstract_system.Xdom, x_n)\n            if x_n in abstract_system.Xdom\n                cell = SY.get_state_by_xpos(abstract_system, x_n)[1]\n                if !(cell in potential)\n                    push!(potential, cell)\n                end\n            end\n        end\n    end\n    return potential\nend\n\nfunction compute_reachable_set(rect::UT.HyperRectangle, concrete_system, Udom)\n    r = (rect.ub - rect.lb) / 2.0 + concrete_system.measnoise\n    Fr = r\n    x = UT.get_center(rect)\n    n = UT.get_dims(rect)\n    lb = fill(Inf, n)\n    ub = fill(-Inf, n)\n    for upos in DO.enum_pos(Udom)\n        u = DO.get_coord_by_pos(Udom.grid, upos)\n        Fx = concrete_system.f_eval(x, u)\n        lb = min.(lb, Fx .- Fr)\n        ub = max.(ub, Fx .+ Fr)\n    end\n    lb = SVector{n}(lb)\n    ub = SVector{n}(ub)\n    return UT.HyperRectangle(lb, ub)\nend\n\nminimum_transition_cost(symmodel, contsys, source, target) = 1.0\n\nconcrete_problem = SimpleProblem.problem(;\n    rectX = UT.HyperRectangle(SVector(0.0, 0.0), SVector(60.0, 60.0)),\n    obstacles = [UT.HyperRectangle(SVector(22.0, 21.0), SVector(25.0, 32.0))],\n    periodic = Int[],\n    periods = [30.0, 30.0],\n    T0 = [0.0, 0.0],\n    rectU = UT.HyperRectangle(SVector(-2.0, -2.0), SVector(2.0, 2.0)),\n    Uobstacles = [UT.HyperRectangle(SVector(-0.5, -0.5), SVector(0.5, 0.5))],\n    _I_ = UT.HyperRectangle(SVector(6.5, 6.5), SVector(7.5, 7.5)),\n    _T_ = UT.HyperRectangle(SVector(44.0, 43.0), SVector(49.0, 48.0)),\n    state_cost = UT.ZeroFunction(),\n    transition_cost = UT.ConstantControlFunction(1.0),\n    tstep = 0.8,\n    measnoise = SVector(0.0, 0.0),\n)\n\nconcrete_system = concrete_problem.system;\nnothing #hide","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"Local optimizer parameters","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"hx_local = [0.5, 0.5]\nhx_heuristic = [1.0, 1.0]\nu0 = SVector(0.0, 0.0)\nhu = SVector(0.5, 0.5)\nUgrid = DO.GridFree(u0, hu)\n\nlocal_optimizer = MOI.instantiate(AB.LazyAbstraction.Optimizer)\n\nAB.LazyAbstraction.set_optimizer_parameters!(\n    local_optimizer,\n    100,\n    pre_image,\n    post_image,\n    compute_reachable_set,\n    minimum_transition_cost,\n    hx_local,\n    hx_heuristic;\n    γ = 10.0,\n)","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"Global optimizer parameters","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"hx_global = [10.0, 10.0]\nu0 = SVector(0.0, 0.0)\nhu = SVector(0.5, 0.5)\nUgrid = DO.GridFree(u0, hu)\nmax_iter = 6\nmax_time = 1000\n\noptimizer = MOI.instantiate(AB.HierarchicalAbstraction.Optimizer)\n\nAB.HierarchicalAbstraction.set_optimizer!(\n    optimizer,\n    concrete_problem,\n    hx_global,\n    Ugrid,\n    compute_reachable_set,\n    minimum_transition_cost,\n    local_optimizer,\n    max_iter,\n    max_time;\n    option = true,\n)\n\nusing Suppressor\n@suppress begin\n    MOI.optimize!(optimizer)\nend","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"Get the results","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_system\"))\n\nprintln(\"Solved : \", optimizer.solved)","category":"page"},{"location":"generated/Hierarchical-abstraction/#Simulation","page":"Hierarchical-abstraction","title":"Simulation","text":"","category":"section"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"x0 = UT.get_center(concrete_problem.initial_set)\ncost_control_trajectory =\n    AB.HierarchicalAbstraction.get_closed_loop_trajectory(optimizer, x0)\ncost = sum(cost_control_trajectory.costs.seq);\nprintln(\n    \"Goal set reached: $(ST.get_state(cost_control_trajectory, ST.length(cost_control_trajectory))∈concrete_problem.target_set)\",\n)\nprintln(\"Cost:\\t $(cost)\")","category":"page"},{"location":"generated/Hierarchical-abstraction/#Display-the-results","page":"Hierarchical-abstraction","title":"Display the results","text":"","category":"section"},{"location":"generated/Hierarchical-abstraction/#Display-the-specifications,-domains-and-trajectory","page":"Hierarchical-abstraction","title":"Display the specifications, domains and trajectory","text":"","category":"section"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"fig = plot(; aspect_ratio = :equal);\n\n#We display the concrete domain\nplot!(concrete_system.X; color = :yellow, opacity = 0.5);\n\n#We display the abstract domain\nplot!(abstract_system.symmodel.Xdom; color = :blue, opacity = 0.5);\n\n#We display the concrete specifications\nplot!(concrete_problem.initial_set; color = :green, opacity = 0.8);\nplot!(concrete_problem.target_set; dims = [1, 2], color = :red, opacity = 0.8);\n\n#We display the concrete trajectory\nplot!(cost_control_trajectory; ms = 0.5)","category":"page"},{"location":"generated/Hierarchical-abstraction/#Display-the-lazy-abstraction","page":"Hierarchical-abstraction","title":"Display the lazy abstraction","text":"","category":"section"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"fig = plot(; aspect_ratio = :equal);\n\nplot!(\n    optimizer.hierarchical_problem;\n    path = optimizer.optimizer_BB.best_sol,\n    heuristic = false,\n    fine = true,\n)\nplot!(cost_control_trajectory; ms = 0.5)","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"","category":"page"},{"location":"generated/Hierarchical-abstraction/","page":"Hierarchical-abstraction","title":"Hierarchical-abstraction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"EditURL = \"../examples/solvers/Path planning.jl\"","category":"page"},{"location":"generated/Path planning/#Example:-Path-planning-problem-solved-by-[Uniform-grid-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"Path planning","title":"Example: Path planning problem solved by Uniform grid abstraction.","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"This example was borrowed from (Reissig et al., 2016; IX. Examples, A) whose dynamics comes from the model given in (Åström and Murray, 2007; Ch. 2.4). This is a reachability problem for a continuous system.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Let us consider the 3-dimensional state space control system of the form","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"dotx = f(x u)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"with f mathbbR^3  U  mathbbR^3 given by","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"f(x(u_1u_2)) = beginbmatrix u_1 cos(α+x_3)cos(α)^-1  u_1 sin(α+x_3)cos(α)^-1  u_1 tan(u_2)  endbmatrix","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"and with U = 1 1 times 1 1 and α = arctan(tan(u_2)2). Here, (x_1 x_2) is the position and x_3 is the orientation of the vehicle in the 2-dimensional plane. The control inputs u_1 and u_2 are the rear wheel velocity and the steering angle. The control objective is to drive the vehicle which is situated in a maze made of obstacles from an initial position to a target position.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"In order to study the concrete system and its symbolic abstraction in a unified framework, we will solve the problem for the sampled system with a sampling time tau. For the construction of the relations in the abstraction, it is necessary to over-approximate attainable sets of a particular cell. In this example, we consider the used of a growth bound function (Reissig et al., 2016; VIII.2, VIII.5) which is one of the possible methods to over-approximate attainable sets of a particular cell based on the state reach by its center.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"For this reachability problem, the abstraction controller is built by solving a fixed-point equation which consists in computing the pre-image of the target set.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"First, let us import StaticArrays and Plots.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"using StaticArrays, Plots","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"At this point, we import Dionysos and JuMP.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"using Dionysos, JuMP","category":"page"},{"location":"generated/Path planning/#Definition-of-the-problem","page":"Path planning","title":"Definition of the problem","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We define the problem using JuMP as follows. We first create a JuMP model:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"model = Model(Dionysos.Optimizer)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Define the state variables: x1(t), x2(t), x3(t)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"x_low, x_upp = [0.0, 0.0, -pi - 0.4], [4.0, 10.0, pi + 0.4]\nx_start = [0.4, 0.4, 0.0]\n@variable(model, x_low[i] <= x[i = 1:3] <= x_upp[i], start = x_start[i])","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Define the control variables: u1(t), u2(t)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"@variable(model, -1 <= u[1:2] <= 1)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Set α(t) = arctan(tan(u2(t)) / 2)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"@expression(model, α, atan(tan(u[2]) / 2))\n\n@constraint(model, ∂(x[1]) == u[1] * cos(α + x[3]) * sec(α))\n@constraint(model, ∂(x[2]) == u[1] * sin(α + x[3]) * sec(α))\n@constraint(model, ∂(x[3]) == u[1] * tan(u[2]))\n\nx_target = [3.3, 0.5, 0]\n\n@constraint(model, final(x[1]) in MOI.Interval(3.0, 3.6))\n@constraint(model, final(x[2]) in MOI.Interval(0.3, 0.8))\n@constraint(model, final(x[3]) in MOI.Interval(-100.0, 100.0))","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Obstacle boundaries (provided)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"x1_lb = [1.0, 2.2, 2.2]\nx1_ub = [1.2, 2.4, 2.4]\nx2_lb = [0.0, 0.0, 6.0]\nx2_ub = [9.0, 5.0, 10.0]","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Function to add rectangular obstacle avoidance constraints","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"for i in eachindex(x1_ub)\n    @constraint(\n        model,\n        x[1:2] ∉ MOI.HyperRectangle([x1_lb[i], x2_lb[i]], [x1_ub[i], x2_ub[i]])\n    )\nend","category":"page"},{"location":"generated/Path planning/#Definition-of-the-abstraction","page":"Path planning","title":"Definition of the abstraction","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the grid of the state-space on which the abstraction is based (origin x0 and state-space discretization h):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We define the growth bound function of f:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"function jacobian_bound(u)\n    β = abs(u[1] / cos(atan(tan(u[2]) / 2)))\n    return StaticArrays.SMatrix{3, 3}(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, β, β, 0.0)\nend\nset_attribute(model, \"jacobian_bound\", jacobian_bound)\n\nset_attribute(model, \"time_step\", 0.3)\n\nx0 = SVector(0.0, 0.0, 0.0);\nh = SVector(0.2, 0.2, 0.2);\nset_attribute(model, \"state_grid\", Dionysos.Domain.GridFree(x0, h))","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the grid of the input-space on which the abstraction is based (origin u0 and input-space discretization h):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"u0 = SVector(0.0, 0.0);\nh = SVector(0.3, 0.3);\nset_attribute(model, \"input_grid\", Dionysos.Domain.GridFree(u0, h))\n\noptimize!(model)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Get the results","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"abstract_system = get_attribute(model, \"abstract_system\");\nabstract_problem = get_attribute(model, \"abstract_problem\");\nabstract_controller = get_attribute(model, \"abstract_controller\");\nconcrete_controller = get_attribute(model, \"concrete_controller\")\nconcrete_problem = get_attribute(model, \"concrete_problem\");\nconcrete_system = concrete_problem.system","category":"page"},{"location":"generated/Path planning/#Trajectory-display","page":"Path planning","title":"Trajectory display","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We choose a stopping criterion reached and the maximal number of steps nsteps for the sampled system, i.e. the total elapsed time: nstep*tstep as well as the true initial state x0 which is contained in the initial state-space _I_ defined previously.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"nstep = 100\nfunction reached(x)\n    if x ∈ concrete_problem.target_set\n        return true\n    else\n        return false\n    end\nend\n\nx0 = SVector(0.4, 0.4, 0.0)\ncontrol_trajectory = Dionysos.System.get_closed_loop_trajectory(\n    get_attribute(model, \"discretized_system\"),\n    concrete_controller,\n    x0,\n    nstep;\n    stopping = reached,\n)\n\nusing Plots","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Here we display the coordinate projection on the two first components of the state space along the trajectory.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"fig = plot(; aspect_ratio = :equal);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We display the concrete domain","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"plot!(concrete_system.X; color = :yellow, opacity = 0.5);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We display the abstract domain","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"plot!(abstract_system.Xdom; color = :blue, opacity = 0.5);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We display the concrete specifications","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"plot!(concrete_problem.initial_set; color = :green, opacity = 0.2);\nplot!(concrete_problem.target_set; dims = [1, 2], color = :red, opacity = 0.2);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We display the abstract specifications","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"plot!(\n    Dionysos.Symbolic.get_domain_from_symbols(\n        abstract_system,\n        abstract_problem.initial_set,\n    );\n    color = :green,\n);\nplot!(\n    Dionysos.Symbolic.get_domain_from_symbols(abstract_system, abstract_problem.target_set);\n    color = :red,\n);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We display the concrete trajectory","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"plot!(control_trajectory; ms = 0.5)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"EditURL = \"../examples/utils/Tree.jl\"","category":"page"},{"location":"generated/Tree/#Tree","page":"Tree","title":"Tree","text":"","category":"section"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"In this file, we present the Tree data structure, which is a tree composed of costs on edges and an underlying metric between node states. In this simple example, the states are two-dimensional ellipsoids.","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"First, let us import a few packages that are necessary to run this example.","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"using LinearAlgebra, Plots, Colors","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"The main package Dionysos provides most important data structures that we will need.","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"using Dionysos\nconst UT = Dionysos.Utils","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"We define the underlying metric between node states","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"distance(E1::UT.Ellipsoid, E2::UT.Ellipsoid) = UT.pointCenterDistance(E1, E2.c)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"We define the action function to compute a transition between two states","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"get_action(E1::UT.Ellipsoid, E2::UT.Ellipsoid) = (1.0, 1.0)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"We define the ellipsoids that will make up our tree states","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"Ellipsoids = [\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 8.0, [-10.0; -10.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 5.0, [0.0; -10.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 1.0, [-10.0; 0.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 3.0, [20.0; -10.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 3.0, [-1.0; 0.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 3.0, [1.0; -8.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 3.0, [-1.0; 5.0]),\n    UT.Ellipsoid(Matrix{Float64}(I(2)) * 3.0, [3.0; 0.0]),\n]","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"We define the root of the tree","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"tree = UT.Tree(Ellipsoids[1])","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"Compute the transition between Ellipsoids[2] and the root of the tree","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"action, cost = get_action(Ellipsoids[2], tree.root.state)\nnNode2 = UT.add_node!(tree, Ellipsoids[2], tree.root, action, cost)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"Connect Ellipsoids[3] to its closest node according to the underlying metric","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"nNode3 = UT.add_closest_node!(tree, Ellipsoids[3], distance, get_action)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"Connect the other ellipsoids","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"nNode4 = UT.add_closest_node!(tree, Ellipsoids[4], distance, get_action)\nnNode5 = UT.add_closest_node!(tree, Ellipsoids[5], distance, get_action)\nnNode6 = UT.add_closest_node!(tree, Ellipsoids[6], distance, get_action)\nnNode7 = UT.add_closest_node!(tree, Ellipsoids[7], distance, get_action)\nnNode8 = UT.add_closest_node!(tree, Ellipsoids[8], distance, get_action)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"Plot the tree","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"println(tree)\nfig = plot(; aspect_ratio = :equal)\nplot!(tree; arrowsB = true, cost = true)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"We change the node's cost and update the tree accordingly","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"nNode3.path_cost = 5.0\nUT.propagate_cost_to_leaves(nNode3)\nfig = plot(; aspect_ratio = :equal)\nplot!(tree)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"We change the node's parent","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"UT.rewire(tree, nNode5, nNode6, 1.0, 1.0)\nfig = plot(; aspect_ratio = :equal)\nplot!(tree)","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"","category":"page"},{"location":"generated/Tree/","page":"Tree","title":"Tree","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/manual/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Dionysos aims to design a controller for a system mathcalS so that the closed-loop system satisfies the specification Sigma where:","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"the system mathcalS is specified by MathematicalSystems or HybridSystems objects;\nthe specification Sigma is specified by ProblemType objects;\nthe solver mathcalO implementents the abstract type AbstractOptimizer of MathOptInterface.","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"So a control problem (mathcalSSigma) can be solved by mathcalO via the JuMP interface, with Dionysos inheriting JuMP's powerful and practical optimization framework.","category":"page"},{"location":"manual/manual/#Overview-of-the-code-structure","page":"Overview","title":"Overview of the code structure","text":"","category":"section"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Description of the core of the Dionysos.jl package, the src folder:","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Subfolder Description\nutils Contains useful functions, data structures, classic search algorithms, file management, ...\ndomain Contains structures defining the domain of a system\nsystem Contains a description of specific systems\nproblem Contains control problems that can be solved by Dionysos solvers\nsymbolic Contains the data structures needed to encode the abstractions\noptim Contains the solvers","category":"page"},{"location":"manual/manual/#Systems","page":"Overview","title":"Systems","text":"","category":"section"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"The system types supported in Dionysos.jl are:","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"MathematicalSystems, which proposes generic and flexible system definitions (e.g.     discrete-time/continuous-time, constrained, noisy systems), such that, for example, the system MathematicalSystems.NoisyConstrainedAffineControlDiscreteSystem of the form x(k+1) = A x(k) + B u(k) + c + D w(k)  x(k)inmathcalX  u(k)inmathcalU w(k)inmathcalW forall k","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"where mathcalX is the state constraint, mathcalU is the input constraint and mathcalW is the noise constraint.","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"HybridSystems, which extends the class of systems of MathematicalSystems to hybrid systems.","category":"page"},{"location":"manual/manual/#Problems","page":"Overview","title":"Problems","text":"","category":"section"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"The problem types supported in Dionysos.jl are:","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Type Description\nReach-avoid optimal control problem (mathcalSmathcalImathcalTmathcalVmathcalC T), where mathcalS is the system, mathcalI is the initial set, mathcalT is the target set, mathcalVmathcalXrightarrow mathbbR is the cost state function, mathcalCmathcalXtimes mathcalUrightarrow mathbbR is the transition cost function, T is the time limit to satisfy the specification.\nSafety control problem (mathcalSmathcalImathcalS T), where mathcalS is the system, mathcalI is the initial set, mathcalS is the safe set,  T is the time during which safety must be ensured.","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Extensions for linear temporal logic (LTL) specifications are currently being implemented.","category":"page"},{"location":"manual/manual/#Solvers","page":"Overview","title":"Solvers","text":"","category":"section"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"The following tables summarize the different solvers. ","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Abstraction-based solver types implemented in Dionysos.jl:","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Type Full vs partial discretization Partition vs Cover Shape Local controller Abstraction System Reference\nUniform grid abstraction Full Partition Hyperrectangle Piece-wise constant Non-determinisitic Continuous-time SCOTS: A Tool for the Synthesis of Symbolic Controllers\nLazy abstraction Partial Partition Hyperrectangle Piece-wise constant Non-determinisitic Continuous-time Alternating simulation on hierarchical abstractions\nHierarchical abstraction Partial Partition Hyperrectangle Piece-wise constant Non-determinisitic Continuous-time Alternating simulation on hierarchical abstractions\nEllipsoid abstraction Full Cover Ellipsoid Piece-wise affine Determinisitic Discrete-time affine State-feedback Abstractions for Optimal Control of Piecewise-affine Systems\nLazy ellipsoid abstraction Partial Cover Ellipsoid Piece-wise affine Determinisitic Discrete-time non-linear Not yet published","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Non abstraction-based solver types implemented in Dionysos.jl:","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Type Description Reference\nBemporad Morari Optimal control of hybrid systems via a predictive control scheme using mixed integer quadratic programming (MIQP) online optimization procedures. Control of systems integrating logic, dynamics, and constraints\nBranchAndBound Optimal control of hybrid systems via a predictive control scheme combining a branch and bound algorithm that can refine Q-functions using Lagrangian duality. Abstraction-based branch and bound approach to Q-learning for hybrid optimal control","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Solver interface","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Each solver is defined by a module which must implement the abstract type AbstractOptimizer and the Optimize! function. For example, for the UniformGridAbstraction solver, this structure and function are defined as follows","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"using JuMP\n\nmutable struct Optimizer{T} <: MOI.AbstractOptimizer\n    concrete_problem::Union{Nothing, PR.ProblemType}\n    abstract_problem::Union{Nothing, PR.OptimalControlProblem, PR.SafetyProblem}\n    abstract_system::Union{Nothing, SY.SymbolicModelList}\n    abstract_controller::Union{Nothing, UT.SortedTupleSet{2, NTuple{2, Int}}}\n    concrete_controller::Any\n    state_grid::Union{Nothing, DO.Grid}\n    input_grid::Union{Nothing, DO.Grid}\n    function Optimizer{T}() where {T}\n        return new{T}(nothing, nothing, nothing, nothing, nothing, nothing, nothing)\n    end\nend","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"and","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"function MOI.optimize!(optimizer::Optimizer)\n    # Build the abstraction\n    abstract_system = build_abstraction(\n        optimizer.concrete_problem.system,\n        optimizer.state_grid,\n        optimizer.input_grid,\n    )\n    optimizer.abstract_system = abstract_system\n    # Build the abstract problem\n    abstract_problem = build_abstract_problem(optimizer.concrete_problem, abstract_system)\n    optimizer.abstract_problem = abstract_problem\n    # Solve the abstract problem\n    abstract_controller = solve_abstract_problem(abstract_problem)\n    optimizer.abstract_controller = abstract_controller\n    # Solve the concrete problem\n    optimizer.concrete_controller =\n        solve_concrete_problem(abstract_system, abstract_controller)\n    return\nend","category":"page"},{"location":"manual/manual/#Running-an-example","page":"Overview","title":"Running an example","text":"","category":"section"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"In this section, we outline how to define and solve a control problem with Dionsysos. For an executable version of this example, see Solvers: Path planning problem in the documentation.","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Define a control problem, i.e., the system and the specification of the desired closed loop behaviour. To do this, you can define new ones yourself or directly load an existing benchmark, for example","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"concrete_problem = PathPlanning.problem(; simple = true, approx_mode = PathPlanning.GROWTH);\nconcrete_system = concrete_problem.system;","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Choose the solver you wish to use","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"using JuMP\noptimizer = MOI.instantiate(AB.UniformGridAbstraction.Optimizer)","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Define the solver's meta-parameters","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"x0 = SVector(0.0, 0.0, 0.0);\nhx = SVector(0.2, 0.2, 0.2);\nstate_grid = DO.GridFree(x0, hx);\nu0 = SVector(0.0, 0.0);\nhu = SVector(0.3, 0.3);\ninput_grid = DO.GridFree(u0, hu);","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Set the solver's meta-parameters","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"MOI.set(optimizer, MOI.RawOptimizerAttribute(\"concrete_problem\"), concrete_problem)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"state_grid\"), state_grid)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"input_grid\"), input_grid)","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Solve the control problem","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"MOI.optimize!(optimizer)","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"Get the results","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_system\"))\nabstract_problem = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_problem\"))\nabstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_controller\"))\nconcrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_controller\"))","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"In Dionysos, all the structures that could be relevant to plot (such as trajectories, state-space discretization, specifications, obstacles, etc.)  have an associated @recipe function, which makes it very easy to plot all the results using the single common plot function of Plots.jl. For example","category":"page"},{"location":"manual/manual/","page":"Overview","title":"Overview","text":"using Plots\n\nplot!(concrete_system.X; color = :yellow, opacity = 0.5);\nplot!(abstract_system.Xdom; color = :blue, opacity = 0.5);\nplot!(concrete_problem.initial_set; color = :green, opacity = 0.2);\nplot!(concrete_problem.target_set; dims = [1, 2], color = :red, opacity = 0.2);\nplot!(control_trajectory; ms = 0.5)","category":"page"},{"location":"reference/Optim/#Optim","page":"Optim","title":"Optim","text":"","category":"section"},{"location":"reference/Optim/","page":"Optim","title":"Optim","text":"This folder contains all the different (abstraction-based or not) solvers that can be used. Note that all the solvers are defined using the MathOptInterface framework: for each solver, we define a subtype of  AbstractOptimizer and implement the Optimize! function.","category":"page"},{"location":"reference/Optim/#Abstraction-based-solvers","page":"Optim","title":"Abstraction-based solvers","text":"","category":"section"},{"location":"reference/Optim/","page":"Optim","title":"Optim","text":"Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer\nDionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer\nDionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer\nDionysos.Optim.Abstraction.LazyAbstraction.Optimizer\nDionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer","category":"page"},{"location":"reference/Optim/#Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer","page":"Optim","title":"Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nSolver based on the classical abstraction method (used for instance in SCOTS) for which the whole domain is partioned into hyper-rectangular cells, independently of the control task.\n\n\n\n\n\n","category":"type"},{"location":"reference/Optim/#Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer","page":"Optim","title":"Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nAbstraction-based solver for which the domain is covered with ellipsoidal cells, independently of the control task.\n\n\n\n\n\n","category":"type"},{"location":"reference/Optim/#Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer","page":"Optim","title":"Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nAbstraction-based solver for which the domain is initially partioned into coarse hyper-rectangular cells, which are iteratively locally smartly refined with respect to the control task.\n\n\n\n\n\n","category":"type"},{"location":"reference/Optim/#Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer","page":"Optim","title":"Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nAbstraction-based solver for which the hyper-rectangular abstraction and the controller are co-designed to reduce the computation cost of the abstraction.\n\n\n\n\n\n","category":"type"},{"location":"reference/Optim/#Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer","page":"Optim","title":"Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nAbstraction-based solver using the lazy abstraction method with ellipsoidal cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/Optim/#Other-solvers","page":"Optim","title":"Other solvers","text":"","category":"section"},{"location":"reference/Optim/","page":"Optim","title":"Optim","text":"Dionysos.Optim.BemporadMorari.Optimizer\nDionysos.Optim.BranchAndBound.Optimizer","category":"page"},{"location":"reference/Optim/#Dionysos.Optim.BemporadMorari.Optimizer","page":"Optim","title":"Dionysos.Optim.BemporadMorari.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nBemporad Morari solver: Optimal control of hybrid systems via a predictive control scheme using mixed integer quadratic programming (MIQP) online optimization procedures.\n\n\n\n\n\n","category":"type"},{"location":"reference/Optim/#Dionysos.Optim.BranchAndBound.Optimizer","page":"Optim","title":"Dionysos.Optim.BranchAndBound.Optimizer","text":"Optimizer{T} <: MOI.AbstractOptimizer\n\nBranch and bound solver: Optimal control of hybrid systems via a predictive control scheme combining a branch and bound algorithm that can refine Q-functions using Lagrangian duality.\n\n\n\n\n\n","category":"type"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"EditURL = \"../examples/solvers/State-feedback Abstraction PWA System.jl\"","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Example:-Optimal-control-of-a-PWA-System-by-State-feedback-Abstractions-solved-by-[Ellipsoid-abstraction](https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/manual/manual.md#solvers).","page":"State-feedback Abstraction PWA System","title":"Example: Optimal control of a PWA System by State-feedback Abstractions solved by Ellipsoid abstraction.","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"This document reproduces [1, Example 2], which is a possible application of state-feedback transition system for the optimal control of piecewise-affine systems. Consider a system mathcalS=(mathcalX mathcalUrightarrow_F) with the transition function","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"beginequation\n    A_psi(x)x+B_psi(x)u+g_psi(x)oplusOmega_psi(x)\nendequation","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"where psimathcalXrightarrow1dotsN_p selects one of the N_p subsystems defined by the matrices","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"beginequation\n\tA_1=beginbmatrix\n    101  03\n    -01  101\nendbmatrix B_1=beginbmatrix\n    10 0  1\nendbmatrixg_1=beginbmatrix\n-01-01\nendbmatrix\nendequation","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"A_2=A_1^top A_3=A_1B_2=B_3=B_1g_2=0","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"and g_3=-g_1. These systems are three spiral sources with unstable equilibria at x_e1=-0963503654^topx_e2=0 and x_e3=-x_e1. We also define the additive-noise sets Omega_1=Omega_2=Omega_3=-005005^2, the control-input set mathcalU=-0505^2 and the state space mathcalX=-22^2. The N_p=3 partitions of mathcalX are mathcalX_1= xinmathcalXx_1leq-1 mathcalX_3= xinmathcalXx_11  and mathcalX_2=mathcalXsetminus(mathcalX_1cupmathcalX_3). The goal is to bring the state x from the initial set mathcalX_0 to a final set mathcalX_*, while avoiding the obstacle mathcalO, which are to be defined.","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"First, let us import StaticArrays, LinearAlgebra, CDDLib, Clarabel, Ipopt, and JuMP. We also instantiate our optimizers and CDDLib.","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"using StaticArrays, LinearAlgebra, Polyhedra, Random\nusing MathematicalSystems, HybridSystems\nusing JuMP, Clarabel\nusing SemialgebraicSets, CDDLib\nusing Plots, Colors\nusing Test\nRandom.seed!(0)\n\nusing Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst SY = DI.Symbolic\nconst PR = DI.Problem\nconst OP = DI.Optim\nconst AB = OP.Abstraction\n\nlib = CDDLib.Library() # polyhedron lib\n\ninclude(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"pwa_sys.jl\"))","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Problem-parameters","page":"State-feedback Abstraction PWA System","title":"Problem parameters","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"Notice that in [1] it was used Wsz = 5 and Usz = 50. These, and other values were changed here to speed up the build time of the documentation.","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"Usz = 70 # upper limit on |u|, `Usz = 50` in [1]\nWsz = 3 # `Wsz = 5` in [1]\ndt = 0.01; # discretization step\n\nconcrete_problem =\n    PWAsys.problem(; lib = lib, dt = dt, Usz = Usz, Wsz = Wsz, simple = false)\nconcrete_system = concrete_problem.system","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Abstraction-parameters","page":"State-feedback Abstraction PWA System","title":"Abstraction parameters","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"This is state-space is defined by the HyperRectangle rectX. We also define a control space with the same bounds. This is done because, for a state-feedback abstraction, selecting a controller out of the set of controllers is the same as selecting a destination state out of the set of cells mathcalX_d, given it's determinism. To build this deterministic state-feedback abstraction in alternating simulation relation  with the system as described in [1, Lemma 1], a set of balls of radius 0.2 covering the state space is adopted as cells xiinmathcalX_d. We assume that inside cells intersecting the boundary of partitions of mathcalX the selected piecewise-affine mode is the same all over its interior and given by the mode defined at its center. An alternative to this are discussed in [1]. Let us define the corresponding grid:","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"n_step = 3\nX_origin = SVector(0.0, 0.0);\nX_step = SVector(1.0 / n_step, 1.0 / n_step)\nnx = size(concrete_system.resetmaps[1].A, 1)\nP = (1 / nx) * diagm((X_step ./ 2) .^ (-2))\nstate_grid = DO.GridEllipsoidalRectangular(X_origin, X_step, P, concrete_system.ext[:X]);\nopt_sdp = optimizer_with_attributes(Clarabel.Optimizer, MOI.Silent() => true)\n\noptimizer = MOI.instantiate(AB.EllipsoidsAbstraction.Optimizer)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"concrete_problem\"), concrete_problem)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"state_grid\"), state_grid)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"sdp_solver\"), opt_sdp)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"Build the state-feedback abstraction and solve the optimal control problem by through Dijkstra's algorithm [2, p.86].","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"MOI.optimize!(optimizer)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"Get the results","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_system\"))\nabstract_problem = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_problem\"))\nabstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_controller\"))\nconcrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_controller\"))\nabstract_lyap_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"abstract_lyap_fun\"))\nconcrete_lyap_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"concrete_lyap_fun\"))\ntransitionCont = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"transitionCont\"))\ntransitionCost = MOI.get(optimizer, MOI.RawOptimizerAttribute(\"transitionCost\"));\nnothing #hide","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Define-the-mapping-function","page":"State-feedback Abstraction PWA System","title":"Define the mapping function","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"#Return pwa mode for a given x\nget_mode(x) = findfirst(m -> (x ∈ m.X), concrete_system.resetmaps)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"To simplify : \"We assume that inside cells intersecting the boundary of partitions of X the selected piecewise-affine mode is the same all over its interior and given by the mode defined at its center.\"","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"function f_eval1(x, u)\n    currState = SY.get_all_states_by_xpos(\n        abstract_system,\n        DO.crop_to_domain(abstract_system.Xdom, DO.get_all_pos_by_coord(state_grid, x)),\n    )\n    next_action = nothing\n    for action in abstract_controller.data\n        if (action[1] ∩ currState) ≠ []\n            next_action = action\n        end\n    end\n    c = DO.get_coord_by_pos(\n        state_grid,\n        SY.get_xpos_by_state(abstract_system, next_action[1]),\n    )\n    m = get_mode(c)\n    W = concrete_system.ext[:W]\n    w = (2 * (rand(2) .^ (1 / 4)) .- 1) .* W[:, 1]\n    return concrete_system.resetmaps[m].A * x +\n           concrete_system.resetmaps[m].B * u +\n           concrete_system.resetmaps[m].c +\n           w\nend\n\ncost_eval(x, u) = UT.function_value(concrete_problem.transition_cost[1][1], x, u)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Simulation","page":"State-feedback Abstraction PWA System","title":"Simulation","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"We define the stopping criteria for a simulation","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"nstep = typeof(concrete_problem.time) == PR.Infinity ? 100 : concrete_problem.time; #max num of steps\nfunction reached(x)\n    currState = SY.get_all_states_by_xpos(\n        abstract_system,\n        DO.crop_to_domain(abstract_system.Xdom, DO.get_all_pos_by_coord(state_grid, x)),\n    )\n    if !isempty(currState ∩ abstract_problem.target_set)\n        return true\n    else\n        return false\n    end\nend","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"We simulate the closed loop trajectory","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"x0 = concrete_problem.initial_set\ncost_control_trajectory = ST.get_closed_loop_trajectory(\n    f_eval1,\n    concrete_controller,\n    cost_eval,\n    x0,\n    nstep;\n    stopping = reached,\n)\ncost_bound = concrete_lyap_fun(x0)\ncost_true = sum(cost_control_trajectory.costs.seq);\nprintln(\"Goal set reached\")\nprintln(\"Guaranteed cost:\\t $(cost_bound)\")\nprintln(\"True cost:\\t\\t $(cost_true)\")","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Visualize-the-results.","page":"State-feedback Abstraction PWA System","title":"Visualize the results.","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"rectX = concrete_system.ext[:X];\nnothing #hide","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Display-the-specifications-and-domains","page":"State-feedback Abstraction PWA System","title":"Display the specifications and domains","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n);\nxlims!(rectX.A.lb[1] - 0.2, rectX.A.ub[1] + 0.2);\nylims!(rectX.A.lb[2] - 0.2, rectX.A.ub[2] + 0.2);\nxlabel!(\"\\$x_1\\$\");\nylabel!(\"\\$x_2\\$\");\ntitle!(\"Specifictions and domains\");\n#We display the concrete domain\nplot!(rectX; color = :yellow, opacity = 0.5);\n#We display the abstract domain\nplot!(abstract_system.Xdom; color = :blue, opacity = 0.5);\n#We display the abstract specifications\nplot!(\n    SY.get_domain_from_symbols(abstract_system, abstract_problem.initial_set);\n    color = :green,\n    opacity = 0.5,\n);\nplot!(\n    SY.get_domain_from_symbols(abstract_system, abstract_problem.target_set);\n    color = :red,\n    opacity = 0.5,\n);\n#We display the concrete specifications\nplot!(UT.DrawPoint(concrete_problem.initial_set); color = :green, opacity = 1.0);\nplot!(UT.DrawPoint(concrete_problem.target_set); color = :red, opacity = 1.0)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Display-the-abstraction","page":"State-feedback Abstraction PWA System","title":"Display the abstraction","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n);\nxlims!(rectX.A.lb[1] - 0.2, rectX.A.ub[1] + 0.2);\nylims!(rectX.A.lb[2] - 0.2, rectX.A.ub[2] + 0.2);\ntitle!(\"Abstractions\");\nplot!(abstract_system; arrowsB = true, cost = false)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#Display-the-Lyapunov-function-and-the-trajectory","page":"State-feedback Abstraction PWA System","title":"Display the Lyapunov function and the trajectory","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"fig = plot(;\n    aspect_ratio = :equal,\n    xtickfontsize = 10,\n    ytickfontsize = 10,\n    guidefontsize = 16,\n    titlefontsize = 14,\n);\nxlims!(rectX.A.lb[1] - 0.2, rectX.A.ub[1] + 0.2);\nylims!(rectX.A.lb[2] - 0.2, rectX.A.ub[2] + 0.2);\nxlabel!(\"\\$x_1\\$\");\nylabel!(\"\\$x_2\\$\");\ntitle!(\"Trajectory and Lyapunov-like Fun.\");\nplot!(abstract_system; arrowsB = false, cost = true, lyap_fun = optimizer.lyap);\nplot!(cost_control_trajectory; color = :black)","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/#References","page":"State-feedback Abstraction PWA System","title":"References","text":"","category":"section"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"L. N. Egidio, T. Alves Lima, R. M. Jungers, \"State-feedback Abstractions for Optimal Control of Piecewise-affine Systems\", IEEE 61st Conference on Decision and Control (CDC), 2022, accepted.\nD. Bertsekas, \"Dynamic programming and optimal control\". Volume I, Athena scientific, 2012.","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"","category":"page"},{"location":"generated/State-feedback Abstraction PWA System/","page":"State-feedback Abstraction PWA System","title":"State-feedback Abstraction PWA System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/Mapping/#Mapping","page":"Mapping","title":"Mapping","text":"","category":"section"},{"location":"reference/Mapping/","page":"Mapping","title":"Mapping","text":"This folder contains mappings to make the link between the concrete domain and the abstract domain, and vice-versa.","category":"page"},{"location":"reference/Mapping/","page":"Mapping","title":"Mapping","text":"Dionysos.Mapping.MappingContinuousGrid\nDionysos.Mapping.MappingContinuousEllipsoid","category":"page"},{"location":"reference/Mapping/#Dionysos.Mapping.MappingContinuousGrid","page":"Mapping","title":"Dionysos.Mapping.MappingContinuousGrid","text":"MappingContinuousGrid(C::DO.ContinuousDomain, D::DomainList{N,T,S<:DO.Grid{N,T}}\n\nMapping containing methods to convert elements in a ContinuousDomain to a grid-based DomainList and vice-versa.\n\n\n\n\n\n","category":"type"},{"location":"reference/Mapping/#Dionysos.Mapping.MappingContinuousEllipsoid","page":"Mapping","title":"Dionysos.Mapping.MappingContinuousEllipsoid","text":"MappingContinuousEllipsoid{C<:DO.ContinuousDomain{N,T}, CE<:DO.ContinuousBoundedEllipsoidDomain{N,T,B,E}}\n\nMapping containing methods to convert elements in a ContinuousDomain to a ContinuousBoundedEllipsoidDomain and vice-versa.\n\n\n\n\n\n","category":"type"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Reissig, G.; Weber, A. and Rungger, M. (2016). Feedback refinement relations for the synthesis of symbolic controllers. IEEE Transactions on Automatic Control 62, 1781–1796.\n\n\n\nÅström, K. J. and Murray, R. M. (2007). Feedback systems. An Introduction for Scientists and Engineers, Karl Johan Aström and Richard M Murray, 27–64.\n\n\n\n","category":"page"},{"location":"","page":"Index","title":"Index","text":"<img class=\"display-light-only\" src=\"assets/logo.png\" height=\"240\" alt=\"Dionysos Logo\">\n<img class=\"display-dark-only\" src=\"assets/logo-dark.png\" height=\"240\" alt=\"Dionysos Logo\">","category":"page"},{"location":"#Introduction","page":"Index","title":"Introduction","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Welcome to the documentation for Dionysos!","category":"page"},{"location":"#What-is-Dionysos-?","page":"Index","title":"What is Dionysos ?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Dionysos is the software of the ERC project Learning to control (L2C) embedded in Julia. In view of the Cyber-Physical Revolution, the only sensible way of controlling these complex systems is often by discretizing the different variables, thus transforming the model into a simple combinatorial problem on a finite-state automaton, called an abstraction of this system. The goal of L2C is to transform this approach into an effective, scalable, cutting-edge technology that will address the CPS challenges and unlock their potential. This ambitious goal will be achieved by leveraging powerful tools from Mathematical Engineering.","category":"page"},{"location":"#Current-version","page":"Index","title":"Current version","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"The current version is still in the making, and allows to solve problems such as reachability problems for hybrid systems.","category":"page"},{"location":"#Longterm-objectives","page":"Index","title":"Longterm objectives","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Rather than relying on closed-form analysis of a model of the dynamical system, Dionysos will learn the optimal control from data, whether harvested from the physical system or generated synthetically. It will rely on a novel methodology, combining the efficiency of several modern optimization/control-theoretic/machine-learning techniques with the theoretical power of the Abstraction approach. All the pieces of the architecture are chosen to foster black-box and data-driven analysis, thereby matching rising and unresolved challenges. Summarizing, the objectives are","category":"page"},{"location":"","page":"Index","title":"Index","text":"To develop a mathematical and algorithmic framework for efficient Abstraction of Cyber-Physical Systems thriving on recent technologies in Optimization and Control;\nTo leverage this framework in situations where the system is described by data, rather than a classical model.","category":"page"},{"location":"#Structure-of-the-documentation","page":"Index","title":"Structure of the documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"The documentation is organised as follows.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The Manual section contains all the useful information to use Dionysos as a user.\nThe Solvers section contains a few examples of solving problems with Dionysos. Start with Getting started if you want to get familiar with Dionysos.\nThe Utils section contains some examples of basic Dionysos functions.\nThe API Reference sections contains all the functions that we currently use in Dionysos. \nThe Developer Docs section is dedicated to the contributors to Dionysos developement. ","category":"page"},{"location":"#Need-help?","page":"Index","title":"Need help?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"If you need help, open an issue on Github.","category":"page"},{"location":"#ERC-sponsor","page":"Index","title":"ERC sponsor","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme under grant agreement No 864017 - L2C.","category":"page"},{"location":"","page":"Index","title":"Index","text":"<img class=\"display-light-only\" src=\"assets/logo_erc_white.jpg\" alt=\"ERC logo\"/>\n<img class=\"display-dark-only\" src=\"assets/logo_erc_black.jpg\" alt=\"ERC logo\"/>","category":"page"}]
}
