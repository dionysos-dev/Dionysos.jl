<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optim · Dionysos</title><meta name="title" content="Optim · Dionysos"/><meta property="og:title" content="Optim · Dionysos"/><meta property="twitter:title" content="Optim · Dionysos"/><meta name="description" content="Documentation for Dionysos."/><meta property="og:description" content="Documentation for Dionysos."/><meta property="twitter:description" content="Documentation for Dionysos."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Dionysos logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Dionysos logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dionysos</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Index</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/abstraction-based-control/">Abstraction-based control</a></li><li><a class="tocitem" href="../../manual/manual/">Overview</a></li></ul></li><li><a class="tocitem" href="../../generated/Getting Started/">Getting Started</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../generated/DC-DC converter/">DC-DC converter</a></li><li><a class="tocitem" href="../../generated/Gol, Lazar &amp; Belta (2013)/">Gol, Lazar &amp; Belta (2013)</a></li><li><a class="tocitem" href="../../generated/Hierarchical-abstraction/">Hierarchical-abstraction</a></li><li><a class="tocitem" href="../../generated/Lazy-Ellipsoids-Abstraction/">Lazy-Ellipsoids-Abstraction</a></li><li><a class="tocitem" href="../../generated/Lazy-abstraction-reachability/">Lazy-abstraction-reachability</a></li><li><a class="tocitem" href="../../generated/Path planning/">Path planning</a></li><li><a class="tocitem" href="../../generated/Single pendulum/">Single pendulum</a></li><li><a class="tocitem" href="../../generated/State-feedback Abstraction PWA System/">State-feedback Abstraction PWA System</a></li><li><a class="tocitem" href="../../generated/Unicycle robot/">Unicycle robot</a></li></ul></li><li><span class="tocitem">Utils</span><ul><li><a class="tocitem" href="../../generated/Ellipsoids/">Ellipsoids</a></li><li><a class="tocitem" href="../../generated/Grid/">Grid</a></li><li><a class="tocitem" href="../../generated/Tree/">Tree</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../Domain/">Domain</a></li><li><a class="tocitem" href="../Mapping/">Mapping</a></li><li class="is-active"><a class="tocitem" href>Optim</a><ul class="internal"><li><a class="tocitem" href="#Abstraction-based-solvers"><span>Abstraction-based solvers</span></a></li><li><a class="tocitem" href="#Other-solvers"><span>Other solvers</span></a></li></ul></li><li><a class="tocitem" href="../Problem/">Problem</a></li><li><a class="tocitem" href="../Symbolic/">Symbolic</a></li><li><a class="tocitem" href="../System/">System</a></li><li><a class="tocitem" href="../Utils/">Utils</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developers/setup/">Set up</a></li><li><a class="tocitem" href="../../developers/git/">Git</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Optim</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optim</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dionysos-dev/Dionysos.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/reference/Optim.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optim"><a class="docs-heading-anchor" href="#Optim">Optim</a><a id="Optim-1"></a><a class="docs-heading-anchor-permalink" href="#Optim" title="Permalink"></a></h1><p>This folder contains all the different (abstraction-based or not) solvers that can be used. Note that all the solvers are defined using the MathOptInterface framework as a subtype of  <a href="https://jump.dev/MathOptInterface.jl/stable/reference/models/#MathOptInterface.AbstractOptimizer"><code>AbstractOptimizer</code></a> by implementig the <a href="https://jump.dev/MathOptInterface.jl/stable/reference/models/#MathOptInterface.optimize!"><code>optimize!</code></a> function.</p><h2 id="Abstraction-based-solvers"><a class="docs-heading-anchor" href="#Abstraction-based-solvers">Abstraction-based solvers</a><a id="Abstraction-based-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Abstraction-based-solvers" title="Permalink"></a></h2><h3 id="Uniform-grid-abstraction-solver"><a class="docs-heading-anchor" href="#Uniform-grid-abstraction-solver">Uniform grid abstraction solver</a><a id="Uniform-grid-abstraction-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Uniform-grid-abstraction-solver" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>A high-level abstraction-based solver that automatically orchestrates system abstraction and control synthesis.   This wrapper follows the <strong>classical abstraction pipeline</strong> (e.g., as in SCOTS), where the state and input spaces are discretized into hyper-rectangular cells, independent of the specific control task.</p><p>It delegates responsibility to modular sub-solvers: one for abstraction and one for control, depending on the type of problem to be solved.</p><hr/><p><strong>Structure and Sub-solvers</strong></p><p>The optimizer internally manages two sub-solvers:</p><ul><li><p><code>abstraction_solver</code>: <a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>OptimizerEmptyProblem</code></a>:   Used to compute the symbolic abstraction of the system from its dynamics and domain.</p></li><li><p><code>control_solver</code>: One of the following control-specific optimizers, depending on the problem type:</p><ul><li><a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem"><code>OptimizerOptimalControlProblem</code></a>: for <a href="../Problem/#Dionysos.Problem.OptimalControlProblem"><code>reachability/optimal control problems</code></a>.</li><li><a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem"><code>OptimizerSafetyProblem</code></a>: for <a href="../Problem/#Dionysos.Problem.SafetyProblem"><code>safety problems</code></a>.</li></ul></li></ul><hr/><p><strong>Behavior</strong></p><ul><li><p>The user sets the control task via:   <code>MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)</code>   where <code>my_problem</code> is a subtype of <a href="../Problem/#Dionysos.Problem.ProblemType"><code>ProblemType</code></a>.</p></li><li><p>The optimizer automatically dispatches to the appropriate control solver based on the problem type.</p></li><li><p>If the abstraction has not yet been computed, it is automatically built <strong>before</strong> solving the control problem.</p></li><li><p>Once computed, the abstraction is cached — switching the control problem (e.g., from safety to reachability) does not recompute it.</p></li><li><p>The field <code>solve_time_sec</code> tracks the runtime of the last call to <code>MOI.optimize!</code>.</p></li><li><p>The resulting controller and value function are stored and can be queried from the wrapper.</p></li></ul><hr/><p><strong>User-settable and access to subsolver fields</strong></p><p>Via <code>MOI.set(...)</code>, the user may configure <code>abstraction_solver</code> and <code>control_solver</code> parameters. Any field accessible in the sub-solvers (abstraction or control) can be transparently accessed via:</p><pre><code class="language-julia hljs">MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;state_grid&quot;), grid)
MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_value_function&quot;))</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.UniformGridAbstraction.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;state_grid&quot;), state_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;input_grid&quot;), input_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;time_step&quot;), 0.1)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;solve_time_sec&quot;))
value_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_value_function&quot;))
controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_controller&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/uniform_grid_abstraction.jl#L26-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerEmptyProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>A solver responsible for constructing an <strong>abstraction of the system dynamics</strong>, independently of the control specification.</p><p>This optimizer wraps everything needed to solve an <a href="../Problem/#Dionysos.Problem.EmptyProblem"><code>EmptyProblem</code></a>, which is used to generate a symbolic model (abstraction) of either a continuous- or discrete-time system.</p><hr/><p><strong>Purpose</strong></p><p>This optimizer builds a symbolic abstraction by simulating or approximating the behavior of the given system.   The abstraction method is chosen via the <code>approx_mode</code> field, and determines which parameters and approximation logic are used.</p><hr/><p><strong>Parameters</strong></p><p><strong>Mandatory fields set by the user</strong></p><ul><li><p><code>empty_problem</code> (<strong>required</strong>):   An instance of <a href="../Problem/#Dionysos.Problem.EmptyProblem"><code>EmptyProblem</code></a> containing the system to abstract and the state region.</p></li><li><p><code>state_grid</code> (<strong>required</strong>):   The discretization grid for the state space.</p></li><li><p>If <code>state_grid</code> is not provided, you must set:</p><ul><li><code>h::SVector{N, T}</code>: Grid spacing vector (used to construct the grid internally).</li></ul></li><li><p><code>input_grid</code> (<strong>required</strong>):   The discretization grid for the input space.</p></li></ul><p><strong>Optional user-tunable fields</strong></p><ul><li><p><code>time_step</code> (optional, required if the system is continuous):   Time step used for discretizing or simulating continuous-time systems.</p></li><li><p><code>nsystem</code> (optional, default = <code>5</code>):   Number of substeps to use when simulating continuous-time systems (e.g., in Runge-Kutta integration).</p></li><li><p><code>approx_mode</code> (<strong>required</strong>):   The abstraction technique to use. Supported modes:</p><ul><li><p><a href="../System/#Dionysos.System.DiscreteTimeOverApproximationMap"><code>USER_DEFINED</code></a>:   Use a custom overapproximation function.   Set <code>overapproximation_map::Function</code>.</p></li><li><p><a href="../System/#Dionysos.System.DiscreteTimeGrowthBound"><code>GROWTH</code></a>:   Use growth-bound based overapproximation.   Set <code>jacobian_bound</code>, optionally <code>growthbound_map</code>, <code>ngrowthbound</code>.</p></li><li><p><a href="../System/#Dionysos.System.DiscreteTimeLinearized"><code>LINEARIZED</code></a>:   Use linearization + Jacobian/Hessian.   Set <code>DF_sys</code>, <code>bound_DF</code>, and <code>bound_DDF</code>.</p></li><li><p><a href="../System/#Dionysos.System.DiscreteTimeCenteredSimulation"><code>CENTER_SIMULATION</code></a>:   Simulate the center of each cell only.</p></li><li><p><a href="../System/#Dionysos.System.DiscreteTimeRandomSimulation"><code>RANDOM_SIMULATION</code></a>:   Sample and simulate random points in each cell.   Set <code>n_samples</code>.</p></li></ul></li><li><p><code>efficient</code> (optional, default = <code>true</code>):   Whether to use optimized internal routines based on <code>approx_mode</code>.</p></li><li><p><code>print_level</code> (optional, default = <code>1</code>):   Verbosity level:</p><ul><li><code>0</code>: silent  </li><li><code>1</code>: standard  </li><li><code>2</code>: verbose/debug</li></ul></li><li><p><code>use_periodic_domain</code> (optional, default = <code>false</code>):   If <code>true</code>, uses a periodic domain structure when discretizing the state space.</p><p>When enabled, the following fields are required:</p><ul><li><code>periodic_dims::SVector{P, Int}</code>:   Indices of the periodic dimensions.</li><li><code>periodic_periods::SVector{P, T}</code>:   Period length for each periodic dimension.</li><li><code>periodic_start::SVector{P, T}</code> (optional):   Start point of each periodic dimension. Defaults to <code>0.0</code> if not provided.</li></ul></li></ul><hr/><p><strong>Internally computed fields (after <code>MOI.optimize!</code>)</strong></p><ul><li><p><code>abstract_system</code>:   The resulting symbolic abstraction, of type <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>SymbolicModelList</code></a>.</p></li><li><p><code>discrete_time_system</code>:   Internally constructed discrete-time version of the system used during abstraction.</p></li><li><p><code>abstraction_construction_time_sec</code>:   Time (in seconds) spent constructing the abstraction.</p></li></ul><p><strong>System approximation objects (derived from <code>approx_mode</code>)</strong></p><ul><li><p><code>continuous_time_system_approximation</code>:   A <a href="../System/#Dionysos.System.ContinuousTimeSystemApproximation"><code>ContinuousTimeSystemApproximation</code></a>, automatically created if the original system is continuous.</p></li><li><p><code>discrete_time_system_approximation</code>:   A <a href="../System/#Dionysos.System.DiscreteTimeSystemApproximation"><code>DiscreteTimeSystemApproximation</code></a>, created in all cases.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.OptimizerEmptyProblem.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;empty_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;state_grid&quot;), state_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;input_grid&quot;), input_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;time_step&quot;), 0.1)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;approx_mode&quot;), GROWTH)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;jacobian_bound&quot;), my_jacobian_bound)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstraction_construction_time_sec&quot;))
abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_system&quot;))
discrete_time_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;discrete_time_system&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/empty_problem.jl#L3-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerOptimalControlProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>An optimizer that solves reachability or reach-avoid <strong>optimal control problems</strong> using symbolic abstractions of the system.</p><p>This solver takes as input a concrete problem (typically an instance of <a href="../Problem/#Dionysos.Problem.OptimalControlProblem"><code>OptimalControlProblem</code></a>) and a symbolic abstraction of the system (i.e., an <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>abstract_system</code></a>). It then solves the <strong>abstract</strong> version of the control problem.</p><p><strong>Key Behavior</strong></p><ul><li>Lifts the concrete problem to the symbolic abstraction space (<code>abstract_system</code>) and constructs the corresponding <code>abstract_problem</code>.</li><li>Computes the <code>controllable_set</code> — the largest set of abstract states from which reachability can be guaranteed.</li><li>Synthesizes an <code>abstract_controller</code> that brings the system to the target set under worst-case dynamics.</li><li>Computes the <code>abstract_value_function</code> that maps each state (cell) to the worst-case number of steps needed to reach the target.</li><li>The solver is successful if the field <code>success</code> is <code>true</code> after <code>MOI.optimize!</code>.</li></ul><hr/><p><strong>Parameters</strong></p><p><strong>Mandatory fields set by the user</strong></p><ul><li><p><code>concrete_problem</code> (<strong>required</strong>):   An instance of <a href="../Problem/#Dionysos.Problem.OptimalControlProblem"><code>OptimalControlProblem</code></a> that defines the reach-avoid task (system, initial set, target, costs, horizon).</p></li><li><p><code>abstract_system</code> (<strong>required</strong>):   The symbolic abstraction of the system, usually obtained from an abstraction optimizer such as <a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>OptimizerEmptyProblem</code></a>.</p></li></ul><p><strong>Optional user-tunable parameters</strong></p><ul><li><p><code>early_stop</code> (optional, default = <code>false</code>):   If <code>true</code>, the fixpoint algorithm stops early when the initial set is fully contained in the controllable set.   If <code>false</code>, it computes the entire maximal controllable set.</p></li><li><p><code>sparse_input</code> (optional, default = <code>false</code>):   If <code>true</code>, uses a sparse representation of the transition table, reducing memory usage when the number of inputs is large but only few are admissible per state (e.g., in <a href="../Symbolic/#Dionysos.Symbolic.determinize_symbolic_model"><code>determinized abstractions</code></a>, with <code>new_input = (input, target)</code>).</p></li><li><p><code>print_level</code> (optional, default = <code>1</code>):   Controls verbosity:  </p><ul><li><code>0</code>: silent  </li><li><code>1</code>: default  </li><li><code>2</code>: detailed logging</li></ul></li></ul><p><strong>Internally computed fields</strong></p><p>These fields are generated automatically during <code>MOI.optimize!</code>.</p><ul><li><code>abstract_problem</code>: The lifted version of the concrete problem over the abstract system.</li><li><code>abstract_problem_time_sec</code>: Time taken to solve the abstract problem.</li><li><code>abstract_controller</code>: A controller mapping abstract states to control inputs.</li><li><code>controllable_set</code>: Set of abstract states from which the target is reachable.</li><li><code>uncontrollable_set</code>: Complementary states with no admissible reachability strategy.</li><li><code>value_fun_tab</code>: Tabular value function over abstract states (e.g., cost-to-go or step count).</li><li><code>abstract_value_function</code>: Functional form of the abstract value function.</li><li><code>concrete_value_function</code>: Functional form of the value function mapped back to the original system.</li><li><code>success</code>: Boolean flag indicating whether the solver completed successfully.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.OptimizerOptimalControlProblem.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_system&quot;), abstract_system)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_problem_time_sec&quot;))
controllable_set = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;controllable_set&quot;))
abstract_value_function = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_value_function&quot;))
concrete_value_function = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_value_function&quot;))
concrete_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_controller&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/optimal_control_problem.jl#L1-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerSafetyProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>An optimizer for solving <strong>safety control problems</strong> over symbolic system abstractions.</p><p>This solver takes as input a <a href="../Problem/#Dionysos.Problem.SafetyProblem"><code>SafetyProblem</code></a> and a symbolic abstraction of the system (e.g., a <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>SymbolicModelList</code></a>), and computes a controller that ensures the system remains within a safe set over a time horizon or indefinitely.</p><hr/><p><strong>Key Behavior</strong></p><ul><li>Lifts the concrete safety problem to the abstract domain and builds an <code>abstract_problem</code>.</li><li>Computes the <strong>invariant set</strong>, i.e., the largest set of abstract states from which all trajectories can be safely controlled.</li><li>Synthesizes an <code>abstract_controller</code> that guarantees safety under worst-case transitions.</li><li>The optimization is successful if <code>success == true</code> after calling <code>MOI.optimize!</code>.</li></ul><hr/><p><strong>Parameters</strong></p><p><strong>Mandatory fields set by the user</strong></p><ul><li><p><code>concrete_problem</code> (<strong>required</strong>):   An instance of <a href="../Problem/#Dionysos.Problem.SafetyProblem"><code>SafetyProblem</code></a> that specifies the system, initial set, safe set, and horizon.</p></li><li><p><code>abstract_system</code> (<strong>required</strong>):   A symbolic abstraction of the system, e.g., obtained from <a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>OptimizerEmptyProblem</code></a>.</p></li></ul><p><strong>Optional user-tunable parameters</strong></p><ul><li><code>print_level</code> (optional, default = <code>1</code>):   Controls verbosity:<ul><li><code>0</code>: silent</li><li><code>1</code>: default (info)</li><li><code>2</code>: verbose debug output</li></ul></li></ul><p><strong>Internally computed fields</strong></p><p>These fields are automatically filled in by <code>MOI.optimize!</code>.</p><ul><li><code>abstract_problem</code>: The lifted version of the safety problem in the symbolic domain.</li><li><code>abstract_problem_time_sec</code>: Time taken to solve the safety problem over the abstract system.</li><li><code>abstract_controller</code>: A controller mapping abstract states to admissible inputs that keep the system safe.</li><li><code>invariant_set</code>: The largest subset of abstract states from which safety can be maintained.</li><li><code>invariant_set_complement</code>: States from which safety cannot be guaranteed.</li><li><code>success</code>: Boolean flag indicating whether a valid invariant set and controller were found.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.OptimizerSafetyProblem.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_system&quot;), abstract_system)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_problem_time_sec&quot;))
invariant_set = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;invariant_set&quot;))
abstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_controller&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/safety_problem.jl#L1-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerCoSafeLTLProblem"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerCoSafeLTLProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerCoSafeLTLProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerCoSafeLTLProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for <strong>co-safe LTL control problems</strong>.</p><p>This optimizer takes as input a concrete problem (an instance of <a href="../Problem/#Dionysos.Problem.CoSafeLTLProblem"><code>CoSafeLTLProblem</code></a>) and a symbolic abstraction of the system (i.e., an <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>abstract_system</code></a>), and</p><ol><li>converts the co-safe LTL specification into a <strong>finite monitor / automaton</strong>,</li><li>forms a product between the abstraction and the monitor (implicitly or explicitly),</li><li>synthesizes an abstract controller (policy) on the product,</li><li>constructs a concrete controller.</li></ol><p><strong>Typical workflow</strong></p><pre><code class="language-julia hljs">opt = OptimizerCoSafeLTLProblem()
MOI.set(opt, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), prob)
# plus other parameters (grid, images, translators, ...)
MOI.optimize!(opt)
ctrl = opt.concrete_controller</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/cosafe_LTL_problem.jl#L1-L20">source</a></section></details></article><h3 id="Other-abstraction-based-solvers"><a class="docs-heading-anchor" href="#Other-abstraction-based-solvers">Other abstraction-based solvers</a><a id="Other-abstraction-based-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Other-abstraction-based-solvers" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for which the domain is covered with ellipsoidal cells, independently of the control task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/ellipsoids_abstraction.jl#L17-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for which the domain is initially partioned into coarse hyper-rectangular cells, which are iteratively locally smartly refined with respect to the control task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/hierarchical_abstraction.jl#L24-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for which the hyper-rectangular abstraction and the controller are co-designed to reduce the computation cost of the abstraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/lazy_abstraction.jl#L21-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver using the lazy abstraction method with ellipsoidal cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/lazy_ellipsoids_abstraction.jl#L27-L31">source</a></section></details></article><h2 id="Other-solvers"><a class="docs-heading-anchor" href="#Other-solvers">Other solvers</a><a id="Other-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Other-solvers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Dionysos.Optim.BemporadMorari.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.BemporadMorari.Optimizer"><code>Dionysos.Optim.BemporadMorari.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Bemporad Morari solver: Optimal control of hybrid systems via a predictive control scheme using mixed integer quadratic programming (MIQP) online optimization procedures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/bemporad_morari.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Dionysos.Optim.BranchAndBound.Optimizer"><a class="docstring-binding" href="#Dionysos.Optim.BranchAndBound.Optimizer"><code>Dionysos.Optim.BranchAndBound.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Branch and bound solver: Optimal control of hybrid systems via a predictive control scheme combining a branch and bound algorithm that can refine Q-functions using Lagrangian duality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/branch_and_bound.jl#L16-L20">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Mapping/">« Mapping</a><a class="docs-footer-nextpage" href="../Problem/">Problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 26 January 2026 15:01">Monday 26 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
