<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optim · Dionysos</title><meta name="title" content="Optim · Dionysos"/><meta property="og:title" content="Optim · Dionysos"/><meta property="twitter:title" content="Optim · Dionysos"/><meta name="description" content="Documentation for Dionysos."/><meta property="og:description" content="Documentation for Dionysos."/><meta property="twitter:description" content="Documentation for Dionysos."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Dionysos logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Dionysos logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dionysos</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Index</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/abstraction-based-control/">Abstraction-based control</a></li><li><a class="tocitem" href="../../manual/manual/">Overview</a></li></ul></li><li><a class="tocitem" href="../../generated/Getting Started/">Getting Started</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../generated/DC-DC converter/">DC-DC converter</a></li><li><a class="tocitem" href="../../generated/Gol, Lazar &amp; Belta (2013)/">Gol, Lazar &amp; Belta (2013)</a></li><li><a class="tocitem" href="../../generated/Hierarchical-abstraction/">Hierarchical-abstraction</a></li><li><a class="tocitem" href="../../generated/Lazy-Ellipsoids-Abstraction/">Lazy-Ellipsoids-Abstraction</a></li><li><a class="tocitem" href="../../generated/Lazy-abstraction-reachability/">Lazy-abstraction-reachability</a></li><li><a class="tocitem" href="../../generated/Path planning/">Path planning</a></li><li><a class="tocitem" href="../../generated/Single pendulum/">Single pendulum</a></li><li><a class="tocitem" href="../../generated/State-feedback Abstraction PWA System/">State-feedback Abstraction PWA System</a></li><li><a class="tocitem" href="../../generated/Unicycle robot/">Unicycle robot</a></li></ul></li><li><span class="tocitem">Utils</span><ul><li><a class="tocitem" href="../../generated/Ellipsoids/">Ellipsoids</a></li><li><a class="tocitem" href="../../generated/Grid/">Grid</a></li><li><a class="tocitem" href="../../generated/Tree/">Tree</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../Domain/">Domain</a></li><li><a class="tocitem" href="../Mapping/">Mapping</a></li><li class="is-active"><a class="tocitem" href>Optim</a><ul class="internal"><li><a class="tocitem" href="#Abstraction-based-solvers"><span>Abstraction-based solvers</span></a></li><li><a class="tocitem" href="#Other-solvers"><span>Other solvers</span></a></li></ul></li><li><a class="tocitem" href="../Problem/">Problem</a></li><li><a class="tocitem" href="../Symbolic/">Symbolic</a></li><li><a class="tocitem" href="../System/">System</a></li><li><a class="tocitem" href="../Utils/">Utils</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developers/setup/">Set up</a></li><li><a class="tocitem" href="../../developers/git/">Git</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Optim</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optim</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dionysos-dev/Dionysos.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/reference/Optim.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optim"><a class="docs-heading-anchor" href="#Optim">Optim</a><a id="Optim-1"></a><a class="docs-heading-anchor-permalink" href="#Optim" title="Permalink"></a></h1><p>This folder contains all the different (abstraction-based or not) solvers that can be used. Note that all the solvers are defined using the MathOptInterface framework as a subtype of  <a href="https://jump.dev/MathOptInterface.jl/stable/reference/models/#MathOptInterface.AbstractOptimizer"><code>AbstractOptimizer</code></a> by implementig the <a href="https://jump.dev/MathOptInterface.jl/stable/reference/models/#MathOptInterface.optimize!"><code>optimize!</code></a> function.</p><h2 id="Abstraction-based-solvers"><a class="docs-heading-anchor" href="#Abstraction-based-solvers">Abstraction-based solvers</a><a id="Abstraction-based-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Abstraction-based-solvers" title="Permalink"></a></h2><h3 id="Uniform-grid-abstraction-solver"><a class="docs-heading-anchor" href="#Uniform-grid-abstraction-solver">Uniform grid abstraction solver</a><a id="Uniform-grid-abstraction-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Uniform-grid-abstraction-solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>A solver implementing the classical abstraction method (e.g., used in SCOTS), where the entire domain is partitioned into hyper-rectangular cells, independent of the specific control task.  The optimizer is structured into modular sub-solvers, each dedicated to a specific problem type. It ensures that abstraction is computed before solving the control problem, maintaining modularity and extendability.</p><p><strong>Structure</strong></p><p>The optimizer internally manages two sub-solvers:</p><ul><li><a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>OptimizerEmptyProblem</code></a>: computes the abstraction (symbolic model) from the system dynamics.</li><li>A control-specific solver, depending on the problem type:<ul><li><a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem"><code>OptimizerSafetyProblem</code></a>: for safety specifications.</li><li><a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem"><code>OptimizerOptimalControlProblem</code></a>: for reachability/optimal control.</li></ul></li></ul><p><strong>Behavior</strong></p><ul><li>Automatically dispatches the appropriate control solver based on the <a href="../Problem/#Dionysos.Problem.ProblemType"><code>ProblemType</code></a> provided via <code>MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)</code>.</li><li>Ensures that the abstraction is computed <strong>before</strong> solving the control problem.</li><li>Allows the concrete problem to be changed without recomputing the abstraction, as long as the abstraction is already built.</li><li>Stores the resulting <code>abstract_system</code> and synthesizes a corresponding <code>concrete_controller</code>.</li><li>Tracks the time spent during the last <code>MOI.optimize!</code> call via the <code>solve_time_sec</code> field.</li><li>Supports configurable verbosity through <code>print_level</code>:<ul><li><code>print_level = 0</code>: silent mode (no output)</li><li><code>print_level = 1</code>: standard verbosity (default)</li><li><code>print_level = 2</code>: detailed logging and messages</li></ul></li></ul><p><strong>Access to subsolver fields</strong></p><p>Any field or attribute present in the sub-solvers (e.g., <code>state_grid</code>, <code>abstract_value_function</code>, etc.) can be accessed or set transparently through this wrapper optimizer via:</p><pre><code class="language-julia hljs">MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;state_grid&quot;), grid)
MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_value_function&quot;))</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.UniformGridAbstraction.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;state_grid&quot;), state_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;input_grid&quot;), input_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;time_step&quot;), 0.1)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;solve_time_sec&quot;))
value_fun = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_value_function&quot;))
controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_controller&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/uniform_grid_abstraction.jl#L18-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerEmptyProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>A solver responsible for constructing an <strong>abstraction of the system dynamics</strong>, independent of the control problem.   This optimizer encapsulates all parameters required to solve an <a href="../Problem/#Dionysos.Problem.EmptyProblem"><code>EmptyProblem</code></a>, typically used to generate a symbolic model (abstraction) from the continuous or discrete-time system.</p><p><strong>Purpose</strong></p><p>This optimizer performs symbolic abstraction by simulating or approximating the system under different techniques.   The abstraction technique is selected via the <code>approx_mode</code> field.</p><p>Each technique activates a specific set of fields used for approximation.</p><p><strong>User Settings</strong></p><ul><li><code>empty_problem</code>: Instance of <a href="../Problem/#Dionysos.Problem.EmptyProblem"><code>EmptyProblem</code></a>, which defines the system.</li><li><code>state_grid</code>: State space discretization.</li><li><code>input_grid</code>: Input space discretization.</li></ul><p><strong>Continuous-Time System Settings</strong></p><ul><li><code>time_step</code>: Time step used for simulation or discretization if the system is a continuous-time system.</li><li><code>nsystem</code>: Number of intermediate steps for Runge Kutta simulation.</li></ul><p><strong>Approximation Settings</strong></p><p>Each mode in <code>approx_mode</code> corresponds to different fields:</p><ul><li><p><code>approx_mode</code>: Approximation strategy to use.</p><ul><li><a href="../System/#Dionysos.System.DiscreteTimeOverApproximationMap"><code>USER_DEFINED</code></a> : Custom overapproximation function.<ul><li><code>overapproximation_map::Function</code>: Custom overapproximation function.</li></ul></li><li><a href="../System/#Dionysos.System.DiscreteTimeGrowthBound"><code>GROWTH</code></a> : Growth-bound based overapproximation.<ul><li><code>jacobian_bound</code>: Used to bound system behavior via growth bounds.</li></ul></li><li><a href="../System/#Dionysos.System.DiscreteTimeLinearized"><code>LINEARIZED</code></a> : Linearization-based overapproximation.<ul><li><code>DF_sys</code>, <code>bound_DF</code>, <code>bound_DDF</code>: Jacobian and Hessian-based approximations.</li></ul></li><li><a href="../System/#Dionysos.System.DiscreteTimeCenteredSimulation"><code>CENTER_SIMULATION</code></a> : Only simulates the center of each cell in the grid.</li><li><a href="../System/#Dionysos.System.DiscreteTimeRandomSimulation"><code>RANDOM_SIMULATION</code></a> : Simulates the system using random sampling within the grid cells.<ul><li><code>n_samples</code>: Number of simulation samples per cell in the grid for random sampling-based approximations.</li></ul></li></ul></li><li><p><code>efficient</code>: Whether to optimize internal computations for speed or memory (by using <code>approx_mode</code> specific functions).</p></li><li><p><code>print_level</code>: Level of verbosity (0 = silent, 1 = default, 2 = verbose).</p></li></ul><p><strong>Abstraction Result</strong></p><ul><li><code>abstract_system</code>: The resulting symbolic abstraction, of type <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>SymbolicModelList</code></a>.</li><li><code>discrete_time_system</code>: A discrete-time version of the system used internally for abstraction.</li><li><code>abstraction_construction_time_sec</code>: Time taken (in seconds) to construct the abstraction.</li></ul><p><strong>System Approximation</strong></p><p>These fields are automatically constructed based on the <code>approx_mode</code>: </p><ul><li><code>continuous_time_system_approximation</code>: A <a href="../System/#Dionysos.System.ContinuousTimeSystemApproximation"><code>ContinuousTimeSystemApproximation</code></a> constructed when the original system is continuous. </li><li><code>discrete_time_system_approximation</code>: A <a href="../System/#Dionysos.System.DiscreteTimeSystemApproximation"><code>DiscreteTimeSystemApproximation</code></a> always constructed.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.OptimizerEmptyProblem.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;state_grid&quot;), state_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;input_grid&quot;), input_grid)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;time_step&quot;), 0.1)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;approx_mode&quot;), GROWTH)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;jacobian_bound&quot;), my_jacobian_bound)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstraction_construction_time_sec&quot;))
abstract_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_system&quot;))
discrete_time_system = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;discrete_time_system&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/empty_problem.jl#L3-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerOptimalControlProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerOptimalControlProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>An optimizer that solves reachability or reach-avoid <strong>optimal control problems</strong> using symbolic abstractions of the system.</p><p>This solver takes as input a concrete problem (typically an instance of <a href="../Problem/#Dionysos.Problem.OptimalControlProblem"><code>OptimalControlProblem</code></a>) and a symbolic abstraction of the system (i.e., an <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>abstract_system</code></a>). It then solves the <strong>abstract</strong> versions of the control problem.</p><p><strong>Key Behavior</strong></p><ul><li>Lifts the concrete reachability problem to the symbolic abstraction space (<code>abstract_system</code>) and constructs the corresponding <code>abstract_problem</code>.</li><li>Computes the <code>controllable_set</code> — the largest set of abstract states from which reachability can be guaranteed.</li><li>Synthesizes a <code>abstract_controller</code> that brings the system within the target set under worst-case transitions.</li><li>Computes the <code>abstract_value_function</code> that maps each state (cell) to the worst-case number of steps needed to reach the target set.</li><li>The solver is successful if the field <code>success</code> is <code>true</code> after <code>MOI.optimize!</code>.</li></ul><p><strong>Parameters</strong></p><p><strong>Inputs</strong></p><ul><li><code>concrete_problem</code>: Instance of <a href="../Problem/#Dionysos.Problem.OptimalControlProblem"><code>OptimalControlProblem</code></a>, defining the reach-avoid control task.</li><li><code>abstract_system</code>: The symbolic abstraction of the system, typically produced by an abstraction solver such as <a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>OptimizerEmptyProblem</code></a>.</li></ul><p><strong>Abstract Problem Fields</strong></p><ul><li><code>abstract_problem</code>: The lifted problem expressed over the abstract system.</li><li><code>abstract_controller</code>: Abstract controller.</li><li><code>abstract_problem_time_sec</code>: Time taken to solve the abstract problem.</li></ul><p><strong>Fixpoint Stopping</strong></p><ul><li><code>early_stop</code>: A <code>Bool</code> that allows stopping the fixpoint iteration as soon as the initial set is fully contained in the growing <strong>controllable set</strong>. This is useful in reachability problems where the fixpoint expands the target set outward.</li></ul><p><strong>Memory Optimization</strong></p><ul><li><code>sparse_input</code>: If <code>true</code>, replaces the default state × input transition table with a sparse dictionary-based structure.   This is useful when:<ul><li>The input space is large.</li><li>Only a small subset of inputs are admissible per state.</li><li>For example, in the determinized abstraction case where inputs are of the form <code>new_input = (input, target)</code>.</li></ul></li></ul><p><strong>Output Sets</strong></p><ul><li><code>controllable_set</code>: The set of abstract states from which the target set can be reached (worst-case guaranteed).</li><li><code>uncontrollable_set</code>: Complementary set of unreachable states under the chosen strategy.</li></ul><p><strong>Value Functions</strong></p><ul><li><code>value_fun_tab</code>: A tabular representation storing, for each state, the associated cost or number of steps to reach the target.</li><li><code>abstract_value_function</code>: Maps abstract states (cells) to worst-case cost-to-go.</li><li><code>concrete_value_function</code>: Optionally stores a refined value function over the original (non-abstract) state space.</li></ul><p><strong>Miscellaneous</strong></p><ul><li><code>success</code>: A <code>Bool</code> flag indicating whether the problem was solved successfully.</li><li><code>print_level</code>: Controls verbosity:<ul><li><code>0</code>: silent</li><li><code>1</code>: default (info)</li><li><code>2</code>: detailed logging</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.OptimizerOptimalControlProblem.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_system&quot;), abstract_system)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_problem_time_sec&quot;))
controllable_set = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;controllable_set&quot;))
abstract_value_function = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_value_function&quot;))
concrete_value_function = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_value_function&quot;))
abstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_controller&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/optimal_control_problem.jl#L1-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem" href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem"><code>Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerSafetyProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerSafetyProblem{T} &lt;: MOI.AbstractOptimizer</code></pre><p>An optimizer for solving <strong>safety control problems</strong> on symbolic system abstractions.</p><p>This solver takes a <a href="../Problem/#Dionysos.Problem.SafetyProblem"><code>SafetyProblem</code></a> as input along with a symbolic abstraction of the system (i.e., an <a href="../Symbolic/#Dionysos.Symbolic.SymbolicModelList"><code>abstract_system</code></a>), and computes a <strong>controller</strong> that ensures all trajectories remain within a given safe set indefinitely (i.e., an <strong>invariant set</strong>).</p><p><strong>Key Behavior</strong></p><ul><li>Lifts the concrete safety problem to the symbolic abstraction space (<code>abstract_system</code>) and constructs the corresponding <code>abstract_problem</code>.</li><li>Computes the <code>invariant_set</code> — the largest set of abstract states from which safety can be guaranteed.</li><li>Synthesizes a <code>abstract_controller</code> that keeps the abstract system within this invariant set under worst-case transitions.</li><li>The solver is successful if the field <code>success</code> is <code>true</code> after <code>MOI.optimize!</code>.</li></ul><p><strong>Parameters</strong></p><p><strong>Inputs</strong></p><ul><li><code>concrete_problem</code>: An instance of <a href="../Problem/#Dionysos.Problem.SafetyProblem"><code>SafetyProblem</code></a> that defines the safe set, system, and dynamics.</li><li><code>abstract_system</code>: The symbolic abstraction of the system, such as one produced by <a href="#Dionysos.Optim.Abstraction.UniformGridAbstraction.OptimizerEmptyProblem"><code>OptimizerEmptyProblem</code></a>.</li></ul><p><strong>Abstract Problem Fields</strong></p><ul><li><code>abstract_problem</code>: The lifted safety problem over the abstract model.</li><li><code>abstract_controller</code>: Abstract controller.</li><li><code>abstract_problem_time_sec</code>: Time to solve the abstract safety problem.</li></ul><p><strong>Result Sets</strong></p><ul><li><code>invariant_set</code>: The largest set of abstract states guaranteed to remain within the safe set.</li><li><code>invariant_set_complement</code>: The complement — states from which safety cannot be guaranteed under any control.</li></ul><p><strong>Miscellaneous</strong></p><ul><li><code>success</code>: A <code>Bool</code> flag that is <code>true</code> if a valid invariant set and controller were found.</li><li><code>print_level</code>: Controls verbosity:<ul><li><code>0</code>: silent</li><li><code>1</code>: default (info)</li><li><code>2</code>: verbose logging</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Dionysos, JuMP
optimizer = MOI.instantiate(Dionysos.Optim.OptimizerSafetyProblem.Optimizer)

MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_problem&quot;), my_problem)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_system&quot;), abstract_system)
MOI.set(optimizer, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 2)

MOI.optimize!(optimizer)

time = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;abstract_problem_time_sec&quot;))
invariant_set = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;invariant_set&quot;))
abstract_controller = MOI.get(optimizer, MOI.RawOptimizerAttribute(&quot;concrete_controller&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/UniformGridAbstraction/safety_problem.jl#L1-L57">source</a></section></article><h3 id="Other-abstraction-based-solvers"><a class="docs-heading-anchor" href="#Other-abstraction-based-solvers">Other abstraction-based solvers</a><a id="Other-abstraction-based-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Other-abstraction-based-solvers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer" href="#Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.EllipsoidsAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for which the domain is covered with ellipsoidal cells, independently of the control task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/ellipsoids_abstraction.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer" href="#Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.HierarchicalAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for which the domain is initially partioned into coarse hyper-rectangular cells, which are iteratively locally smartly refined with respect to the control task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/hierarchical_abstraction.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer" href="#Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.LazyAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver for which the hyper-rectangular abstraction and the controller are co-designed to reduce the computation cost of the abstraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/lazy_abstraction.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer" href="#Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer"><code>Dionysos.Optim.Abstraction.LazyEllipsoidsAbstraction.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Abstraction-based solver using the lazy abstraction method with ellipsoidal cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/abstraction/lazy_ellipsoids_abstraction.jl#L21-L25">source</a></section></article><h2 id="Other-solvers"><a class="docs-heading-anchor" href="#Other-solvers">Other solvers</a><a id="Other-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Other-solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.BemporadMorari.Optimizer" href="#Dionysos.Optim.BemporadMorari.Optimizer"><code>Dionysos.Optim.BemporadMorari.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Bemporad Morari solver: Optimal control of hybrid systems via a predictive control scheme using mixed integer quadratic programming (MIQP) online optimization procedures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/bemporad_morari.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dionysos.Optim.BranchAndBound.Optimizer" href="#Dionysos.Optim.BranchAndBound.Optimizer"><code>Dionysos.Optim.BranchAndBound.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer{T} &lt;: MOI.AbstractOptimizer</code></pre><p>Branch and bound solver: Optimal control of hybrid systems via a predictive control scheme combining a branch and bound algorithm that can refine Q-functions using Lagrangian duality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dionysos-dev/Dionysos.jl/blob/v0.1.3/src/optim/branch_and_bound.jl#L16-L20">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Mapping/">« Mapping</a><a class="docs-footer-nextpage" href="../Problem/">Problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 22 April 2025 21:37">Tuesday 22 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
