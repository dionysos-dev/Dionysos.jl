<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path planning · Dionysos</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Dionysos</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Index</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../DC-DC converter/">DC-DC converter</a></li><li><a class="tocitem" href="../Gol, Lazar &amp; Belta (2013)/">Gol, Lazar &amp; Belta (2013)</a></li><li class="is-active"><a class="tocitem" href>Path planning</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Path planning</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Path planning</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/examples/Path planning.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example:-Path-planning-problem"><a class="docs-heading-anchor" href="#Example:-Path-planning-problem">Example: Path planning problem</a><a id="Example:-Path-planning-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Path-planning-problem" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/dionysos-dev/Dionysos.jl/gh-pages?filepath=dev/generated/Path planning.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder"/></a> <a href="https://nbviewer.jupyter.org/github/dionysos-dev/Dionysos.jl/blob/gh-pages/dev/generated/Path planning.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt="nbviewer"/></a></p><p>This example was borrowed from [1, IX. Examples, A] whose dynamics comes from the model given in [2, Ch. 2.4]. This is a <strong>reachability problem</strong> for a <strong>continuous system</strong>.</p><p>Let us consider the 3-dimensional state space control system of the form</p><p class="math-container">\[\dot{x} = f(x, u)\]</p><p>with <span>$f: \mathbb{R}^3 × U ↦ \mathbb{R}^3$</span> given by</p><p class="math-container">\[f(x,(u_1,u_2)) = \begin{bmatrix} u_1 \cos(α+x_3)\cos(α^{-1}) \\ u_1 \sin(α+x_3)\cos(α^{-1}) \\ u_1 \tan(u_2)  \end{bmatrix}\]</p><p>and with <span>$U = [−1, 1] \times [−1, 1]$</span> and <span>$α = \arctan(\tan(u_2)/2)$</span>. Here, <span>$(x_1, x_2)$</span> is the position and <span>$x_3$</span> is the orientation of the vehicle in the 2-dimensional plane. The control inputs <span>$u_1$</span> and <span>$u_2$</span> are the rear wheel velocity and the steering angle. The control objective is to drive the vehicle which is situated in a maze made of obstacles from an initial position to a target position.</p><p>In order to study the concrete system and its symbolic abstraction in a unified framework, we will solve the problem for the sampled system with a sampling time <span>$\tau$</span>.</p><p>The abstraction is based on a feedback refinment relation [1,V.2 Definition]. Basically, this is equivalent to an alternating simulation relationship with the additional constraint that the input of the concrete and symbolic system preserving the relation must be identical. This allows to easily determine the controller of the concrete system from the abstraction controller by simply adding a quantization step.</p><p>For the construction of the relations in the abstraction, it is necessary to over-approximate attainable sets of a particular cell. In this example, we consider the used of a growth bound function  [1, VIII.2, VIII.5] which is one of the possible methods to over-approximate attainable sets of a particular cell based on the state reach by its center. Therefore, it is used to compute the relations in the abstraction based on the feedback refinement relation.</p><p>For this reachability problem, the abstraction controller is built by solving a fixed-point equation which consists in computing the the pre-image of the target set.</p><p>First, let us import <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays</a>.</p><pre><code class="language-julia">using StaticArrays</code></pre><p>At this point, we import the useful Dionysos sub-module for this problem: <a href="https://github.com/dionysos-dev/Dionysos.jl/blob/master/src/Abstraction/abstraction.jl">Abstraction</a>.</p><pre><code class="language-julia">using Dionysos
using Dionysos.Abstraction
AB = Dionysos.Abstraction;</code></pre><h3 id="Definition-of-the-system"><a class="docs-heading-anchor" href="#Definition-of-the-system">Definition of the system</a><a id="Definition-of-the-system-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-system" title="Permalink"></a></h3><p>Definition of the dynamics function <span>$f$</span> of the system:</p><pre><code class="language-julia">function F_sys(x, u)
    α = atan(tan(u[2])/2)
    return SVector{3}(
        u[1]*cos(α + x[3])/cos(α),
        u[1]*sin(α + x[3])/cos(α),
        u[1]*tan(u[2]))
end;</code></pre><p>Definition of the growth bound function of <span>$f$</span>:</p><pre><code class="language-julia">ngrowthbound = 5;
function L_growthbound(u)
    β = abs(u[1]/cos(atan(tan(u[2])/2)))
    return SMatrix{3,3}(
        0.0, 0.0, 0.0,
        0.0, 0.0, 0.0,
        β, β, 0.0)
end;</code></pre><p>Here it is considered that there is no system and measurement noise:</p><pre><code class="language-julia">sysnoise = SVector(0.0, 0.0, 0.0);
measnoise = SVector(0.0, 0.0, 0.0);</code></pre><p>Definition of the discretization time step parameters: <code>tstep</code> and <code>nsys</code>:</p><pre><code class="language-julia">tstep = 0.3;
nsys = 5;</code></pre><p>Finally, we build the control system:</p><pre><code class="language-julia">contsys = AB.NewControlSystemGrowthRK4(tstep, F_sys, L_growthbound, sysnoise,
                                       measnoise, nsys, ngrowthbound);</code></pre><h3 id="Definition-of-the-control-problem"><a class="docs-heading-anchor" href="#Definition-of-the-control-problem">Definition of the control problem</a><a id="Definition-of-the-control-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-control-problem" title="Permalink"></a></h3><p>Definition of the state-space (limited to be rectangle):</p><pre><code class="language-julia">_X_ = AB.HyperRectangle(SVector(0.0, 0.0, -pi - 0.4), SVector(4.0, 10.0, pi + 0.4));</code></pre><p>Definition of the obstacles (limited to be rectangle):</p><pre><code class="language-julia">X1_lb = [1.0, 2.2, 2.2, 3.4, 4.6, 5.8, 5.8, 7.0, 8.2, 8.4, 9.3, 8.4, 9.3, 8.4, 9.3];
X1_ub = [1.2, 2.4, 2.4, 3.6, 4.8, 6.0, 6.0, 7.2, 8.4, 9.3, 10.0, 9.3, 10.0, 9.3, 10.0];
X2_lb = [0.0, 0.0, 6.0, 0.0, 1.0, 0.0, 7.0, 1.0, 0.0, 8.2, 7.0, 5.8, 4.6, 3.4, 2.2];
X2_ub = [9.0, 5.0, 10.0, 9.0, 10.0, 6.0, 10.0, 10.0, 8.5, 8.6, 7.4, 6.2, 5.0, 3.8, 2.6];</code></pre><p>Definition of the input-space (limited to be rectangle):</p><pre><code class="language-julia">_U_ = AB.HyperRectangle(SVector(-1.0, -1.0), SVector(1.0, 1.0));</code></pre><p>Definition of the initial state-space (here it consists in a single point):</p><pre><code class="language-julia">_I_ = AB.HyperRectangle(SVector(0.4, 0.4, 0.0), SVector(0.4, 0.4, 0.0));</code></pre><p>Definition of the target state-space (limited to be hyper-rectangle):</p><pre><code class="language-julia">_T_ = AB.HyperRectangle(SVector(3.0, 0.5, -100.0), SVector(3.6, 0.8, 100.0));</code></pre><h3 id="Definition-of-the-abstraction"><a class="docs-heading-anchor" href="#Definition-of-the-abstraction">Definition of the abstraction</a><a id="Definition-of-the-abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-abstraction" title="Permalink"></a></h3><p>Definition of the grid of the state-space on which the abstraction is based (origin <code>x0</code> and state-space discretization <code>h</code>):</p><pre><code class="language-julia">x0 = SVector(0.0, 0.0, 0.0);
h = SVector(0.2, 0.2, 0.2);
Xgrid = AB.GridFree(x0, h);</code></pre><p>Construction of the struct <code>DomainList</code> containing the feasible cells of the state-space:</p><pre><code class="language-julia">Xfull = AB.DomainList(Xgrid);
AB.add_set!(Xfull, _X_, AB.OUTER)
for (x1lb, x2lb, x1ub, x2ub) in zip(X1_lb, X2_lb, X1_ub, X2_ub)
    box = AB.HyperRectangle(SVector(x1lb, x2lb, _X_.lb[3]), SVector(x1ub, x2ub, _X_.ub[3]))
    if box ⊆ _X_ &amp;&amp; isempty(box ∩ _I_) &amp;&amp; isempty(box ∩ _T_)
        AB.remove_set!(Xfull, box, AB.OUTER)
    end
end</code></pre><p>Definition of the grid of the input-space on which the abstraction is based (origin <code>u0</code> and input-space discretization <code>h</code>):</p><pre><code class="language-julia">u0 = SVector(0.0, 0.0);
h = SVector(0.3, 0.3);
Ugrid = AB.GridFree(u0, h);</code></pre><p>Construction of the struct <code>DomainList</code> containing the quantized inputs:</p><pre><code class="language-julia">Ufull = AB.DomainList(Ugrid);
AB.add_set!(Ufull, _U_, AB.OUTER)</code></pre><p>Construction of the abstraction:</p><pre><code class="language-julia">symmodel = AB.NewSymbolicModelListList(Xfull, Ufull);
@time AB.compute_symmodel_from_controlsystem!(symmodel, contsys)</code></pre><pre class="documenter-example-output">compute_symmodel_from_controlsystem! started
compute_symmodel_from_controlsystem! terminated with success: 13081981 transitions created
  5.446142 seconds (168.93 k allocations: 339.357 MiB, 2.25% gc time, 3.06% compilation time)</pre><h3 id="Construction-of-the-controller"><a class="docs-heading-anchor" href="#Construction-of-the-controller">Construction of the controller</a><a id="Construction-of-the-controller-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-of-the-controller" title="Permalink"></a></h3><p>Computation of the initial symbolic states:</p><pre><code class="language-julia">Xinit = AB.DomainList(Xgrid);
AB.add_subset!(Xinit, Xfull, _I_, AB.OUTER)
initlist = [AB.get_state_by_xpos(symmodel, pos) for pos in AB.enum_pos(Xinit)];</code></pre><p>Computation of the target symbolic states:</p><pre><code class="language-julia">Xtarget = AB.DomainList(Xgrid)
AB.add_subset!(Xtarget, Xfull, _T_, AB.OUTER)
targetlist = [AB.get_state_by_xpos(symmodel, pos) for pos in AB.enum_pos(Xtarget)];</code></pre><p>Construction of the controller:</p><pre><code class="language-julia">contr = AB.NewControllerList();
@time AB.compute_controller_reach!(contr, symmodel.autom, initlist, targetlist)</code></pre><pre class="documenter-example-output">compute_controller_reach! started

compute_controller_reach! terminated with success
  2.410964 seconds (46 allocations: 162.985 MiB)</pre><h3 id="Trajectory-display"><a class="docs-heading-anchor" href="#Trajectory-display">Trajectory display</a><a id="Trajectory-display-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-display" title="Permalink"></a></h3><p>We choose the number of steps <code>nsteps</code> for the sampled system, i.e. the total elapsed time: <code>nstep</code>*<code>tstep</code> as well as the true initial state <code>x0</code> which is contained in the initial state-space <code>_I_</code> defined previously.</p><pre><code class="language-julia">nstep = 100;
x0 = SVector(0.4, 0.4, 0.0);</code></pre><p>Here we display the coordinate projection on the two first components of the state space along the trajectory.</p><p>To complete</p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><ol><li>G. Reissig, A. Weber and M. Rungger, &quot;Feedback Refinement Relations for the Synthesis of Symbolic Controllers,&quot; in IEEE Transactions on Automatic Control, vol. 62, no. 4, pp. 1781-1796.</li><li>K. J. Aström and R. M. Murray, Feedback systems. Princeton University Press, Princeton, NJ, 2008.</li></ol><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Gol, Lazar &amp; Belta (2013)/">« Gol, Lazar &amp; Belta (2013)</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 30 April 2021 16:21">Friday 30 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
