var documenterSearchIndex = {"docs":
[{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/examples/Getting Started.jl\"","category":"page"},{"location":"generated/Getting Started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In this file we will visit the basic functionalities provided by Dionysos for the optimal control of complex systems. In summary, the topics covered are","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Grids and discretizations\nDynamical system declaration\nContinuous and discrete state image mapping\nPlotting","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"First, let us import a few packages that are necessary to run this example.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"using Dionysos\nusing StaticArrays\nusing LinearAlgebra\nusing PyPlot","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The main package Dionysos provides most important data structures that we will need. Additionally  StaticArrays provides faster implementation of Arrays (which have static memory allocation), LinearAlgebra allows us to perform some additional operations and PyPlot is important for data visualization.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"include(\"../../../src/utils/plotting/plotting.jl\")","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The submodule plotting.jl has functions that will be useful for 2D-visualization of the functions that we are implementing.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"const DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst CO = DI.Control\nconst SY = DI.Symbolic","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Additionally, we will short the submodules accondingly","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"We use HyperRectangle to represent the boundary of the state space rectX and the input space rectU.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"rectX = UT.HyperRectangle(SVector(-2, -2), SVector(2, 2));\nrectU = UT.HyperRectangle(SVector(-5), SVector(5));\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"A discretization of the state space is declared using the GridFree structure, which requires the definition of a center x0 and a vector h of discretization steps in each direction.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"x0 = SVector(0.0, 0.0);\nh = SVector(1.0/5, 1.0/5);\nXgrid = DO.GridFree(x0, h);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Xgrid represents the state space grid and holds information of x0 and h, but is not a collection of cells. Indeed, a cell can be efficiently represented by a tuple of Int, for instance 'pos', with which the corresponding cartesian position can be computed by x0 + h .* pos or using functions to be shown. In Dionysos, a set of cells is called a Domain and the DomainList structure is used to represent this set. In the following, domainX is defined as an empty DomainList over the grid Xgrid and the add_set! method is responsible for adding a set of cells to the DomainList","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"domainX = DO.DomainList(Xgrid);\nDO.add_set!(domainX, rectX, DO.INNER)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In this last line of code, add_set! add all the cells of the grid Xgrid to the DomainList domainX that are contained in the HyperRectangle rectX Construction of the struct DomainList containing the feasible cells of the state-space. Note, we used DO.INNER to make sure to add cells entirely contained in the domain. If we would like to add also cells partially covered by a given HyperRectangle, DO.OUTER should be used instead.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Similarly, we define a discretization of the input-space on which the abstraction is based (origin u0 and input-space discretization h):","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"u0 = SVector(0.0);\nh = SVector(1.0/5);\nUgrid = DO.GridFree(u0, h);\ndomainU = DO.DomainList(Ugrid);\nDO.add_set!(domainU, rectU, DO.INNER);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Now we have to define our dynamical system. For the sake of simplicity, note that we consider a linear time-invariant dynamical system but the functions defining it allow the definition of a generic nonlinear and time-dependent system. We also define a step time tstep for discretizing the continuous-time dynamic. The parameters","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"tstep = 0.1;\nnsys=10; # Runge-Kutta pre-scaling\n\n\nA = SMatrix{2,2}(0.0, 1.0,\n                -3.0, 1.0);\nB = SMatrix{2,1}(0.0, 1.0);\n\nF_sys = let A = A\n    (x,u) -> A*x + B*u\nend;\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"We also need to define a growth-bound function, which allows for the state-space discretization errors. For more details on growth bounds, please refer to (Reissig, Weber, and Rungger, 2016).","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"ngrowthbound=10; # Runge-Kutta pre-scaling\nA_diag = diagm(diag(A));\nA_abs = abs.(A) - abs.(A_diag) + A_diag\nL_growthbound = x -> abs.(A)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Finally we define the bounds on the input noise sysnoise and for the measurement noise measnoise of the system","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"measnoise = SVector(0.0, 0.0);\nsysnoise = SVector(0.0, 0.0);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"And now the instantiation of the ControlSystem","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"contsys = ST.NewControlSystemGrowthRK4(tstep, F_sys, L_growthbound, sysnoise,\n                                       measnoise, nsys, ngrowthbound);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"With that in hand, we can now proceed to the construction of a symbolic model of our system","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"symmodel = SY.NewSymbolicModelListList(domainX, domainU);\nnothing #hide","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The method compute_symmodel_from_controlsystem! builds the transitions of the symbolic control system based on the provided domains and the dynamics defined in contsys","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"SY.compute_symmodel_from_controlsystem!(symmodel, contsys)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Let us now explore what transitions have been created considering, for instance, the state x=[1.1  1.3] and the input u=-1. First, let us pin point the cell in the grid associated with this state and this input. The method get_pos_by_coord returns a tuple of integers defining the indices of a cell coontaining a given coordinate.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"xpos = DO.get_pos_by_coord(Xgrid, SVector(1.1, 1.3))\nupos = DO.get_pos_by_coord(Ugrid, SVector(-1))","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"On the other hand, get_coord_by_pos returns the coordinates of the center of a cell defined by its indices.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"x = DO.get_coord_by_pos(Xgrid, xpos)\nu = DO.get_coord_by_pos(Ugrid, upos)","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Now we create the vector post to receive the number of all the cells that are in the Post of x under u.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"post = Int[]\nSY.compute_post!(post, symmodel.autom, symmodel.xpos2int[xpos], symmodel.upos2int[upos])","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"It is important to highlight the differences between xpos and the elements of post. The Tuple xpos contains information about a cell with respect to the grid Xgrid whereas the elements of post are Int's containing an internal code of each cell added to the Symbolic Model symmodel. To alterante between the two different representations we use the dictionaries xint2pos and xpos2int. Similarly, the same can be said about upos. That said, we can build a domain of Post of xpos under upos as following:","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"domainPostx = DO.DomainList(Xgrid);\nfor pos in symmodel.xint2pos[post]\n    DO.add_pos!(domainPostx,pos)\nend","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"Let us visualize this","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"fig = PyPlot.figure()\n\nax = PyPlot.axes(aspect = \"equal\")\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\nvars = [1, 2];\nPlot.domain!(ax, vars, domainX, fc = \"white\")\nPlot.cell!(ax, vars, Xgrid, xpos, fc = \"blue\")\nPlot.domain!(ax, vars, domainPostx, fc = \"green\")\ngcf()","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In the previous picture, we have the state space lattice in white, the chosen cell xpos in blue and the corresponding Post domain in green. The argument vars given to the Plot functions refer to the projection of the state space onto the subspace of variables 1 and 2. In this case this is an identity mapping but for higher-order systems, this projection is useful to visualize the behavior of the system on a 2-dimensional space.","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"generated/Getting Started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"EditURL = \"https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/examples/DC-DC converter.jl\"","category":"page"},{"location":"generated/DC-DC converter/#Example:-DC-DC-converter","page":"DC-DC converter","title":"Example: DC-DC converter","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"We consider a boost DC-DC converter which has been widely studied from the point of view of hybrid control, see for example in  [1, V.A],[2],[3]. This is a safety problem for a switching system.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"(Image: Boost DC-DC converter.)","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"The state of the system is given by x(t) = beginbmatrix i_l(t)  v_c(t) endbmatrix^top. The switching system has two modes consisting in two-dimensional affine dynamics:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"dotx = f_p(x) = A_p x + b_pquad p=12","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"with","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"A_1 = beginbmatrix -fracr_lx_l 0  0  -frac1x_cfrac1r_0+r_c  endbmatrix A_2= beginbmatrix -frac1x_lleft(r_l+fracr_0r_cr_0+r_cright)  -frac1x_lfracr_0r_0+r_c   frac1x_cfracr_0r_0+r_c    -frac1x_cfrac1r_0+r_c  endbmatrix b = beginbmatrix fracv_sx_l0endbmatrix","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"The goal is to design a controller to keep the state of the system in a safety region around the reference desired value, using as input only the switching signal.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"In order to study the concrete system and its symbolic abstraction in a unified framework, we will solve the problem for the sampled system with a sampling time tau.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"The abstraction is based on a feedback refinment relation [4,V.2 Definition]. Basically, this is equivalent to an alternating simulation relationship with the additional constraint that the input of the concrete and symbolic system preserving the relation must be identical. This allows to easily determine the controller of the concrete system from the abstraction controller by simply adding a quantization step.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"For the construction of the relations in the abstraction, it is necessary to over-approximate attainable sets of a particular cell. In this example, we consider the used of a growth bound function  [4, VIII.2, VIII.5] which is one of the possible methods to over-approximate attainable sets of a particular cell based on the state reach by its center. Therefore, it is used to compute the relations in the abstraction based on the feedback refinement relation.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"First, let us import StaticArrays.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"using StaticArrays","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"At this point, we import the useful Dionysos sub-module for this problem: Abstraction.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"using Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst CO = DI.Control\nconst SY = DI.Symbolic","category":"page"},{"location":"generated/DC-DC converter/#Definition-of-the-system","page":"DC-DC converter","title":"Definition of the system","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the parameters of the system:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"vs = 1.0; rL = 0.05; xL = 3.0; rC = 0.005; xC = 70.0; r0 = 1.0;\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the dynamics functions f_p of the system:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"b = SVector(vs/xL, 0.0);\nA1 = SMatrix{2,2}(-rL/xL, 0.0, 0.0, -1.0/xC/(r0+rC));\nA2 = SMatrix{2,2}(-(rL+r0*rC/(r0+rC))/xL, 5.0*r0/(r0+rC)/xC,\n    -r0/(r0+rC)/xL/5.0, -1.0/xC/(r0+rC));\nF_sys = let b = b, A1 = A1, A2 = A2\n    (x, u) -> u[1] == 1 ? A1*x + b : A2*x + b\nend;\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the growth bound functions of f_p:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"ngrowthbound = 5;\nA2_abs = SMatrix{2,2}(-(rL+r0*rC/(r0+rC))/xL, 5.0*r0/(r0+rC)/xC,\n                      r0/(r0+rC)/xL/5.0, -1.0/xC/(r0+rC));\nL_growthbound = let A1 = A1, A2_abs = A2_abs\n    u -> u[1] == 1 ? A1 : A2_abs\nend;\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Here it is considered that there is no system and measurement noise:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"sysnoise = SVector(0.0, 0.0);\nmeasnoise = SVector(0.0, 0.0);\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the discretization time step parameters: tstep and nsys:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"tstep = 0.5;\nnsys = 5;\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Finally, we build the control system:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"contsys = ST.NewControlSystemGrowthRK4(tstep, F_sys, L_growthbound, sysnoise,\n                                       measnoise, nsys, ngrowthbound);\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/#Definition-of-the-control-problem","page":"DC-DC converter","title":"Definition of the control problem","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the state-space (limited to be rectangle):","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"_X_ = UT.HyperRectangle(SVector(1.15, 5.45), SVector(1.55, 5.85));\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the input-space, the later discretization of the input ensures that it can only take the values 1 or 2:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"_U_ = UT.HyperRectangle(SVector(1), SVector(2));\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/#Definition-of-the-abstraction","page":"DC-DC converter","title":"Definition of the abstraction","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the grid of the state-space on which the abstraction is based (origin x0 and state-space discretization h):","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"x0 = SVector(0.0, 0.0);\nh = SVector(2.0/4.0e3, 2.0/4.0e3);\nXgrid = DO.GridFree(x0, h);\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Construction of the struct DomainList containing the feasible cells of the state-space. Note, we used AB.INNER to make sure to add cells entirely contained in the domain because we are working with a safety problem.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Xfull = DO.DomainList(Xgrid);\nDO.add_set!(Xfull, _X_, DO.INNER)","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Definition of the grid of the input-space on which the abstraction is based (origin u0 and input-space discretization h):","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"u0 = SVector(1);\nh = SVector(1);\nUgrid = DO.GridFree(u0, h);\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Construction of the struct DomainList containing the quantized inputs:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Ufull = DO.DomainList(Ugrid);\nDO.add_set!(Ufull, _U_, DO.OUTER);\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Construction of the abstraction:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"symmodel = SY.NewSymbolicModelListList(Xfull, Ufull);\n@time SY.compute_symmodel_from_controlsystem!(symmodel, contsys)","category":"page"},{"location":"generated/DC-DC converter/#Construction-of-the-controller","page":"DC-DC converter","title":"Construction of the controller","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"In this problem, we consider both: the initial state-space and the safety state-space are equal to the entire state-space.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Computation of the initial symbolic states:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Xinit = DO.DomainList(Xgrid);\nunion!(Xinit, Xfull)\ninitlist = [SY.get_state_by_xpos(symmodel, pos) for pos in DO.enum_pos(Xinit)];\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Computation of the safety symbolic states:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Xsafe = DO.DomainList(Xgrid)\nunion!(Xsafe, Xfull)\nsafelist = [SY.get_state_by_xpos(symmodel, pos) for pos in DO.enum_pos(Xsafe)];\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"Construction of the controller:","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"contr = CO.NewControllerList();\n@time CO.compute_controller_safe!(contr, symmodel.autom, initlist, safelist)","category":"page"},{"location":"generated/DC-DC converter/#Trajectory-display","page":"DC-DC converter","title":"Trajectory display","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"We choose the number of steps nsteps for the sampled system, i.e. the total elapsed time: nstep*tstep as well as the true initial state x0 which is contained in the initial state-space defined previously.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"nstep = 300;\nx0 = SVector(1.2, 5.6);\nnothing #hide","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"To complete","category":"page"},{"location":"generated/DC-DC converter/#References","page":"DC-DC converter","title":"References","text":"","category":"section"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"A. Girard, G. Pola and P. Tabuada, \"Approximately Bisimilar Symbolic Models for Incrementally Stable Switched Systems,\" in IEEE Transactions on Automatic Control, vol. 55, no. 1, pp. 116-126, Jan. 2010.\nS. Mouelhi, A. Girard, and G. Gössler. “CoSyMA: a tool for controller synthesis using multi-scale abstractions”. In: HSCC. ACM. 2013, pp. 83–88.\nA. Girard. “Controller synthesis for safety and reachability via approximate bisimulation”. In: Automatica 48.5 (2012), pp. 947–953.\nG. Reissig, A. Weber and M. Rungger, \"Feedback Refinement Relations for the Synthesis of Symbolic Controllers,\" in IEEE Transactions on Automatic Control, vol. 62, no. 4, pp. 1781-1796.","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"","category":"page"},{"location":"generated/DC-DC converter/","page":"DC-DC converter","title":"DC-DC converter","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"EditURL = \"https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/examples/Gol, Lazar & Belta (2013).jl\"","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/#Example:-Gol,-Lazar-and-Belta-(2013)","page":"Gol, Lazar & Belta (2013)","title":"Example: Gol, Lazar and Belta (2013)","text":"","category":"section"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"(Image: Binder) (Image: nbviewer) This example reproduces parts of the numerical results of [3]. A similar example reproducing all results of [3] is available as a codeocean capsule in [4].","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"This example was borrowed from [1, Example VIII.A] and tackles an optimal control for the hybrid system with state evolution governed by","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"x(k+1) = beginbmatrix 1  1  0  1 endbmatrixx(k) + beginbmatrix 05  10 endbmatrix u(k)","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"The goal is to take the state vector toward a target set XT by visiting one of the squares A or B and avoiding the obstacles O1 and O2","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"First, let us import CDDLib, GLPK, OSQP, JuMP, Pavito and Ipopt","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"import CDDLib\nimport GLPK\nimport OSQP\nusing JuMP\nimport Pavito\nimport Cbc\nimport Ipopt","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"At this point we import Dionysos","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"using Dionysos\nusing Dionysos.Control\nusing Dionysos.Problem","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"And the file defining the hybrid system for this problem","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"include(joinpath(dirname(dirname(pathof(Dionysos))), \"problems\", \"GolLazarBelta.jl\"))","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"Now we instantiate our optimal control problem using the function provided by GolLazarBelta.jl","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"problem = GolLazarBelta.problem(CDDLib.Library(), Float64);\nnothing #hide","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"Finally, we select the method presented in [2] as our optimizer","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"qp_solver = optimizer_with_attributes(\n    OSQP.Optimizer,\n    \"eps_abs\" => 1e-8,\n    \"eps_rel\" => 1e-8,\n    \"max_iter\" => 100000,\n    MOI.Silent() => true\n);\n\nmip_solver = optimizer_with_attributes(\n    Cbc.Optimizer,\n    MOI.Silent() => true\n);\n\ncont_solver = optimizer_with_attributes(\n    Ipopt.Optimizer,\n    MOI.Silent() => true\n);\n\nmiqp_solver = optimizer_with_attributes(\n    Pavito.Optimizer,\n    \"mip_solver\" => mip_solver,\n    \"cont_solver\" => cont_solver,\n    MOI.Silent() => true\n);\n\n\nalgo = optimizer_with_attributes(BemporadMorari.Optimizer{Float64},\n    \"continuous_solver\" => qp_solver,\n    \"mixed_integer_solver\" => miqp_solver,\n    \"indicator\" => false,\n    \"log_level\" => 0\n);\nnothing #hide","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"and use it to solve the given problem, with the help of the abstraction layer MathOptInterface provided by JuMP","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"optimizer = MOI.instantiate(algo)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"problem\"), problem)\nMOI.optimize!(optimizer)","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"We check the solver time","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"MOI.get(optimizer, MOI.SolveTimeSec())","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"the termination status","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"termination = MOI.get(optimizer, MOI.TerminationStatus())","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"the objective value","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"objective_value = MOI.get(optimizer, MOI.ObjectiveValue())","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"and recover the corresponding continuous trajectory","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"xu = MOI.get(optimizer, ContinuousTrajectoryAttribute());\nnothing #hide","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"A little bit of data visualization now:","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"using PyPlot\nusing Colors\nusing Polyhedra\nusing HybridSystems\n\n##Auxiliary function for annotating\nfunction text_in_set_plot!(ax, po, t;  fillcolor = :white, linecolor = :black, fillalpha = 1)\n    ##solve finding center (other solvers? https://jump.dev/JuMP.jl/dev/installation/#Supported-solvers)\n    solver = optimizer_with_attributes(GLPK.Optimizer, \"presolve\" => GLPK.GLP_ON)\n    poly = matplotlib.patches.Polygon(GolLazarBelta.get_ordered_vertices(po))\n    poly.set_facecolor(fillcolor)\n    poly.set_edgecolor(linecolor)\n    poly.set_alpha(fillalpha)\n    ax.add_patch(poly)\n\n    if t !== nothing\n        c, r = hchebyshevcenter(hrep(po), solver, verbose=0)\n        ax.annotate(t, c, ha=\"center\", va=\"center\")\n    end\nend\n\n##Initialize our canvas\nfig = PyPlot.figure()\n\nax = PyPlot.axes(aspect = \"equal\")\nax.set_xlim(-10.5,3)\nax.set_ylim(-10.5,3)\n\n##Show the discrete modes\nfor mode in states(problem.system)\n    t = (problem.system.ext[:q_T] in [mode, mode + 11]) ? \"XT\" : (mode == problem.system.ext[:q_A] ? \"A\" : (mode == problem.system.ext[:q_B] ? \"B\" :\n            mode <= 11 ? string(mode) : string(mode - 11)))\n    text_in_set_plot!(ax, stateset(problem.system, mode), t, fillcolor = \"none\", linecolor = :black)\nend\n\n##Plot obstacles\nfor i in eachindex(problem.system.ext[:obstacles])\n    text_in_set_plot!(ax, problem.system.ext[:obstacles][i], \"O$i\", fillcolor = :black, fillalpha = 0.1)\nend\n\n\n##Initial state\nax.scatter([problem.x_0[1]], [problem.x_0[2]])\nax.annotate(\"x0\", [problem.x_0[1], problem.x_0[2]-0.5], ha=\"center\", va=\"center\")\n\n##Split the vector into x1 and x2\nx1 = [xu.x[j][1] for j in eachindex(xu.x)]\nx2 = [xu.x[j][2] for j in eachindex(xu.x)]\n\n##Plot the trajectory\nax.scatter(x1, x2)\ngcf()","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/#References","page":"Gol, Lazar & Belta (2013)","title":"References","text":"","category":"section"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"Gol, E. A., Lazar, M., & Belta, C. (2013). Language-guided controller synthesis for linear systems. IEEE Transactions on Automatic Control, 59(5), 1163-1176.\nBemporad, A., & Morari, M. (1999). Control of systems integrating logic, dynamics, and constraints. Automatica, 35(3), 407-427.\nLegat B., Bouchat J., Jungers R. M. (2021). Abstraction-based branch and bound approach to Q-learning for hybrid optimal control. 3rd Annual Learning for Dynamics & Control Conference, 2021.\nLegat B., Bouchat J., Jungers R. M. (2021). Abstraction-based branch and bound approach to Q-learning for hybrid optimal control. https://www.codeocean.com/. https://doi.org/10.24433/CO.6650697.v1.","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"","category":"page"},{"location":"generated/Gol, Lazar & Belta (2013)/","page":"Gol, Lazar & Belta (2013)","title":"Gol, Lazar & Belta (2013)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/Temporary API/#TempAPI","page":"Temporary API","title":"Temp","text":"","category":"section"},{"location":"reference/Temporary API/","page":"Temporary API","title":"Temporary API","text":"Temporary API Reference file","category":"page"},{"location":"reference/Temporary API/","page":"Temporary API","title":"Temporary API","text":"Dionysos.Utils.expand\nDionysos.Utils.BDD.IntTupleSet\nDionysos.Utils.path_cost\nDionysos.Symbolic.compute_symmodel_from_hybridcontrolsystem!\nDionysos.Utils.breadth_first_graph_search\nDionysos.Utils.depth_first_graph_search\nDionysos.Utils.best_first_graph_search\nDionysos.Utils.path\nDionysos.Utils.AbstractQueue\nDionysos.Symbolic._compute_base_cell\nDionysos.Utils.MyStack\nDionysos.Control.DiscreteTrajectory\nDionysos.Utils.tree_search\nDionysos.Symbolic._get_min_bounding_box\nDionysos.Utils.goal_test\nDionysos.Utils.astar_graph_search\nDionysos.Utils.astar_tree_search\nDionysos.Utils.BDD.BitSet\nDionysos.Symbolic._provide_P\nDionysos.Utils.breadth_first_tree_search\nDionysos.Utils.graph_search\nDionysos.Symbolic.ellipsoid_vol\nDionysos.Symbolic._has_transition\nDionysos.Utils.best_first_tree_search\nDionysos.Utils.successor\nDionysos.Domain.DomainList\nDionysos.Utils.Node\nDionysos.Utils.depth_first_tree_search\nDionysos.Utils.MyPriorityQueue\nDionysos.Utils.FIFOQueue\nDionysos.Control.ContinuousTrajectory\nDionysos.Utils.SearchProblem\nDionysos.Utils.BranchAndBound.Abstract_BB_Problem","category":"page"},{"location":"reference/Temporary API/#Dionysos.Utils.expand","page":"Temporary API","title":"Dionysos.Utils.expand","text":"Yield the nodes reachable from this node.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.BDD.IntTupleSet","page":"Temporary API","title":"Dionysos.Utils.BDD.IntTupleSet","text":"mutable struct IntTupleSet <: AbstractSet{NTuple{N,Int} where N}\n\nSame as Base.Set{NTuple{N,Int} where N} but with CUDD.\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.path_cost","page":"Temporary API","title":"Dionysos.Utils.path_cost","text":"Return the cost of a solution path that arrives at state2 from state1 via action, assuming cost c to get up to state1. If the problem is such that the path doesn't matter, this function will only look at state2.  If the path does matter, it will consider c and maybe state1 and action. The default method costs 1 for every step in the path.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Symbolic.compute_symmodel_from_hybridcontrolsystem!","page":"Temporary API","title":"Dionysos.Symbolic.compute_symmodel_from_hybridcontrolsystem!","text":"compute_symmodel_from_hybridcontrolsystem!(symmodel::SymbolicModel{N}, transitionCost::AbstractDict, transitionKappa::AbstractDict,\nhybridsys::AbstractHybridSystem, W, L, U, opt_sdp, opt_qp)\n\nBuilds an abstraction symmodel where the transitions have costs given in transitionCost and are parameterized by affine-feedback controllers in transitionKappa. The concrete system  is hybridsys and W, L and U are defined as in _has_transition. An SDP optimizer opt_sdp and a QP optimizer opt_qp must be provided as JuMP optimizers.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.breadth_first_graph_search","page":"Temporary API","title":"Dionysos.Utils.breadth_first_graph_search","text":"Search the shallowest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.depth_first_graph_search","page":"Temporary API","title":"Dionysos.Utils.depth_first_graph_search","text":"Search the deepest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.best_first_graph_search","page":"Temporary API","title":"Dionysos.Utils.best_first_graph_search","text":"Search the nodes with the lowest f scores first. You specify the function f(node) that you want to minimize; for example, if f is a heuristic estimate to the goal, then we have greedy best first search; if f is node.depth then we have depth-first search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.path","page":"Temporary API","title":"Dionysos.Utils.path","text":"Create a list of nodes from the root to this node.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.AbstractQueue","page":"Temporary API","title":"Dionysos.Utils.AbstractQueue","text":"AbstractQueue is an abstract type.     There are three types:     MyStack(): A Last In First Out Queue.     FIFOQueue(): A First In First Out Queue.     MyPriorityQueue(f,ext): Queue where items are sorted by f, (default <). Each type supports the following methods and functions:     append!(q,item)  – add an item to the queue     extend!(q,items) – equivalent to: for item in items: append(q,item)     pop!(q)          – return the top item from the queue     length(q)        – number of items in q\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Symbolic._compute_base_cell","page":"Temporary API","title":"Dionysos.Symbolic._compute_base_cell","text":"_compute_base_cell(r::SVector{S})\n\nComputes a polyhedron containing the base hyperrectangular cell, centered at the origin and with the i-th side lenght given by 2*r[i]. \n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.MyStack","page":"Temporary API","title":"Dionysos.Utils.MyStack","text":"Return an empty list, suitable as a Last-In-First-Out Queue.\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Control.DiscreteTrajectory","page":"Temporary API","title":"Dionysos.Control.DiscreteTrajectory","text":"DiscreteTrajectory{Q, TT}\n\nq_0 is the starting mode and transitions is a sequence of discrete transitions in the system\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.tree_search","page":"Temporary API","title":"Dionysos.Utils.tree_search","text":"Search through the successors of a problem to find a goal. The argument fringe should be an empty queue. Don't worry about repeated paths to a state.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Symbolic._get_min_bounding_box","page":"Temporary API","title":"Dionysos.Symbolic._get_min_bounding_box","text":"_get_min_bounding_box(P, optimizer)\n\nFinds the minimum bounding box containing the ellipsoid {x'Px < 1}. \n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.goal_test","page":"Temporary API","title":"Dionysos.Utils.goal_test","text":"Return True if the state is a goal. The default method compares the state to P.goal, as specified in the constructor. Implement this method if checking against a single goal is not enough.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.astar_graph_search","page":"Temporary API","title":"Dionysos.Utils.astar_graph_search","text":"A* search is best-first graph search with f(n) = g(n)+h(n). You need to specify the h function when you call astar_search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.astar_tree_search","page":"Temporary API","title":"Dionysos.Utils.astar_tree_search","text":"A* search is best-first graph search with f(n) = g(n)+h(n). You need to specify the h function when you call astar_search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.BDD.BitSet","page":"Temporary API","title":"Dionysos.Utils.BDD.BitSet","text":"mutable struct BitSet <: AbstractSet{Int}\n\nSame as Base.BitSet but with CUDD.\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Symbolic._provide_P","page":"Temporary API","title":"Dionysos.Symbolic._provide_P","text":"_provide_P(subsys::HybridSystems.ConstrainedAffineControlDiscreteSystem, optimizer)\n\nIf subsys is a stabilizable system, finds the matrix P and the state-feedback gain K that satisfy the discrete-time Lyapunov inequality (A+BK)'P(A+BK)-P < 0. The condition number of P is minimized. optimizer must be a JuMP SDP optimizer.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.breadth_first_tree_search","page":"Temporary API","title":"Dionysos.Utils.breadth_first_tree_search","text":"Search the shallowest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.graph_search","page":"Temporary API","title":"Dionysos.Utils.graph_search","text":"Search through the successors of a problem to find a goal. The argument fringe should be an empty queue. If two paths reach a state, only use the best one.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Symbolic.ellipsoid_vol","page":"Temporary API","title":"Dionysos.Symbolic.ellipsoid_vol","text":"ellipsoid_vol(P,r)\n\nCalculates the n-volume of the n-ellipsoid defined as {x'Px < r}.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Symbolic._has_transition","page":"Temporary API","title":"Dionysos.Symbolic._has_transition","text":"_has_transition(subsys::HybridSystems.ConstrainedAffineControlDiscreteSystem, \n    P, c, Pp, cp, W, L, U, optimizer)\n\nVerifies whether a controller u(x)=K(x-c)+ell exists for subsys satisfying input requirements defined by U ans performs a sucessful transitions from a starting set Bs = {(x-c)'P(x-c) ≤ 1} to the final set Bs = {(x-c)'P(x-c) ≤ 1}. A tight upper bound on the transition cost c(x,u) is  minimized where c(x,u) = |L*[x; u; 1]|^2, from the parameter L and each columm of the matrix   W defines a vertex of the polytope from which additive disturbance are drawn. \n\nThe input restrictions are defined by the list U as |U[i]*u| ≤ 1. optimizer must be a JuMP  SDP optimizer (e.g., Mosek, SDPA, COSMO, ...).\n\nNote\n\nThis implements the optimization problem presented in Corollary 1 of the following paper  https://arxiv.org/pdf/2204.00315.pdf\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.best_first_tree_search","page":"Temporary API","title":"Dionysos.Utils.best_first_tree_search","text":"Search the nodes with the lowest f scores first. You specify the function f(node) that you want to minimize; for example, if f is a heuristic estimate to the goal, then we have greedy best first search; if f is node.depth then we have depth-first search.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.successor","page":"Temporary API","title":"Dionysos.Utils.successor","text":"Given a state, return a sequence of (action, state) pairs reachable from this state. If there are many successors, consider an iterator that yields the successors one at a time, rather than building them all at once.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Domain.DomainList","page":"Temporary API","title":"Dionysos.Domain.DomainList","text":"DomainList{N,T,S<:Grid{N,T}}\n\nStruct for a basic domain\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.Node","page":"Temporary API","title":"Dionysos.Utils.Node","text":"A node in a search tree. Contains a pointer to the parent (the node that this is a successor of) and to the actual state for this node. Note that if a state is arrived at by two paths, then there are two nodes with the same state. Also includes the action that got us to this state, and the total pathcost (also known as g) to reach the node. Other functions may add an f and h value; see bestfirstgraphsearch and astar_search for an explanation of how the f and h values are handled.\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.depth_first_tree_search","page":"Temporary API","title":"Dionysos.Utils.depth_first_tree_search","text":"Search the deepest nodes in the search tree first.\n\n\n\n\n\n","category":"function"},{"location":"reference/Temporary API/#Dionysos.Utils.MyPriorityQueue","page":"Temporary API","title":"Dionysos.Utils.MyPriorityQueue","text":"A queue in which the minimum (or maximum) element (as determined by f) is returned first. Keys of type T and priorities of type V.\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.FIFOQueue","page":"Temporary API","title":"Dionysos.Utils.FIFOQueue","text":"A First-In-First-Out Queue.\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Control.ContinuousTrajectory","page":"Temporary API","title":"Dionysos.Control.ContinuousTrajectory","text":"ContinuousTrajectory{T, XVT<:AbstractVector{T}, UVT<:AbstractVector{T}}\n\nx is a sequence of points in the state space and u is a sequence of points in the input space\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.SearchProblem","page":"Temporary API","title":"Dionysos.Utils.SearchProblem","text":"SearchProblem\n\nFields\n\n- `initial`  -- initial state of type `S` or a list of initial state of type `S`.\n- `goal`     -- possibly a goal state of type 'Union{Nothing,S}''.\n\nExample\n\nstruct Problem{S} <: SearchProblem{S}\n    initial::Union{S,Vector{S}}\n    goal::Union{Nothing,S}\nend\nThe constructor specifies the initial state, and possibly a goal\nstate, if there is a unique goal.\nfunction Problem(initial::S; goal=nothing) where S\n    return Problem{S}(initial,goal)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/Temporary API/#Dionysos.Utils.BranchAndBound.Abstract_BB_Problem","page":"Temporary API","title":"Dionysos.Utils.BranchAndBound.Abstract_BB_Problem","text":"Abstract_BB_Problem #abstract branch and bound problem\n\nSould implement the methods below\n\n\n\n\n\n","category":"type"},{"location":"#Dionysos","page":"Index","title":"Dionysos","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Dionysos implements a solver for the optimal control of cyber-physical systems.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"EditURL = \"https://github.com/dionysos-dev/Dionysos.jl/blob/master/docs/src/examples/Path planning.jl\"","category":"page"},{"location":"generated/Path planning/#Example:-Path-planning-problem","page":"Path planning","title":"Example: Path planning problem","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"(Image: Binder) (Image: nbviewer)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"This example was borrowed from [1, IX. Examples, A] whose dynamics comes from the model given in [2, Ch. 2.4]. This is a reachability problem for a continuous system.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Let us consider the 3-dimensional state space control system of the form","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"dotx = f(x u)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"with f mathbbR^3  U  mathbbR^3 given by","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"f(x(u_1u_2)) = beginbmatrix u_1 cos(α+x_3)cos(α^-1)  u_1 sin(α+x_3)cos(α^-1)  u_1 tan(u_2)  endbmatrix","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"and with U = 1 1 times 1 1 and α = arctan(tan(u_2)2). Here, (x_1 x_2) is the position and x_3 is the orientation of the vehicle in the 2-dimensional plane. The control inputs u_1 and u_2 are the rear wheel velocity and the steering angle. The control objective is to drive the vehicle which is situated in a maze made of obstacles from an initial position to a target position.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"In order to study the concrete system and its symbolic abstraction in a unified framework, we will solve the problem for the sampled system with a sampling time tau.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"The abstraction is based on a feedback refinment relation [1,V.2 Definition]. Basically, this is equivalent to an alternating simulation relationship with the additional constraint that the input of the concrete and symbolic system preserving the relation must be identical. This allows to easily determine the controller of the concrete system from the abstraction controller by simply adding a quantization step.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"For the construction of the relations in the abstraction, it is necessary to over-approximate attainable sets of a particular cell. In this example, we consider the used of a growth bound function  [1, VIII.2, VIII.5] which is one of the possible methods to over-approximate attainable sets of a particular cell based on the state reach by its center. Therefore, it is used to compute the relations in the abstraction based on the feedback refinement relation.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"For this reachability problem, the abstraction controller is built by solving a fixed-point equation which consists in computing the the pre-image of the target set.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"First, let us import StaticArrays.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"using StaticArrays","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"At this point, we import the useful Dionysos sub-module for this problem: Abstraction.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"using Dionysos\nconst DI = Dionysos\nconst UT = DI.Utils\nconst DO = DI.Domain\nconst ST = DI.System\nconst CO = DI.Control\nconst SY = DI.Symbolic","category":"page"},{"location":"generated/Path planning/#Definition-of-the-system","page":"Path planning","title":"Definition of the system","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the dynamics function f of the system:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"function F_sys(x, u)\n    α = atan(tan(u[2])/2)\n    return SVector{3}(\n        u[1]*cos(α + x[3])/cos(α),\n        u[1]*sin(α + x[3])/cos(α),\n        u[1]*tan(u[2]))\nend;\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the growth bound function of f:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"ngrowthbound = 5;\nfunction L_growthbound(u)\n    β = abs(u[1]/cos(atan(tan(u[2])/2)))\n    return SMatrix{3,3}(\n        0.0, 0.0, 0.0,\n        0.0, 0.0, 0.0,\n        β, β, 0.0)\nend;\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Here it is considered that there is no system and measurement noise:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"sysnoise = SVector(0.0, 0.0, 0.0);\nmeasnoise = SVector(0.0, 0.0, 0.0);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the discretization time step parameters: tstep and nsys:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"tstep = 0.3;\nnsys = 5;\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Finally, we build the control system:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"contsys = ST.NewControlSystemGrowthRK4(tstep, F_sys, L_growthbound, sysnoise,\n                                       measnoise, nsys, ngrowthbound);\nnothing #hide","category":"page"},{"location":"generated/Path planning/#Definition-of-the-control-problem","page":"Path planning","title":"Definition of the control problem","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the state-space (limited to be rectangle):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"_X_ = UT.HyperRectangle(SVector(0.0, 0.0, -pi - 0.4), SVector(4.0, 10.0, pi + 0.4));\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the obstacles (limited to be rectangle):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"X1_lb = [1.0, 2.2, 2.2, 3.4, 4.6, 5.8, 5.8, 7.0, 8.2, 8.4, 9.3, 8.4, 9.3, 8.4, 9.3];\nX1_ub = [1.2, 2.4, 2.4, 3.6, 4.8, 6.0, 6.0, 7.2, 8.4, 9.3, 10.0, 9.3, 10.0, 9.3, 10.0];\nX2_lb = [0.0, 0.0, 6.0, 0.0, 1.0, 0.0, 7.0, 1.0, 0.0, 8.2, 7.0, 5.8, 4.6, 3.4, 2.2];\nX2_ub = [9.0, 5.0, 10.0, 9.0, 10.0, 6.0, 10.0, 10.0, 8.5, 8.6, 7.4, 6.2, 5.0, 3.8, 2.6];\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the input-space (limited to be rectangle):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"_U_ = UT.HyperRectangle(SVector(-1.0, -1.0), SVector(1.0, 1.0));\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the initial state-space (here it consists in a single point):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"_I_ = UT.HyperRectangle(SVector(0.4, 0.4, 0.0), SVector(0.4, 0.4, 0.0));\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the target state-space (limited to be hyper-rectangle):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"_T_ = UT.HyperRectangle(SVector(3.0, 0.5, -100.0), SVector(3.6, 0.8, 100.0));\nnothing #hide","category":"page"},{"location":"generated/Path planning/#Definition-of-the-abstraction","page":"Path planning","title":"Definition of the abstraction","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the grid of the state-space on which the abstraction is based (origin x0 and state-space discretization h):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"x0 = SVector(0.0, 0.0, 0.0);\nh = SVector(0.2, 0.2, 0.2);\nXgrid = DO.GridFree(x0, h);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Construction of the struct DomainList containing the feasible cells of the state-space:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Xfull = DO.DomainList(Xgrid);\nDO.add_set!(Xfull, _X_, DO.OUTER)\nfor (x1lb, x2lb, x1ub, x2ub) in zip(X1_lb, X2_lb, X1_ub, X2_ub)\n    box = UT.HyperRectangle(SVector(x1lb, x2lb, _X_.lb[3]), SVector(x1ub, x2ub, _X_.ub[3]))\n    if box ⊆ _X_ && isempty(box ∩ _I_) && isempty(box ∩ _T_)\n        DO.remove_set!(Xfull, box, DO.OUTER)\n    end\nend","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Definition of the grid of the input-space on which the abstraction is based (origin u0 and input-space discretization h):","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"u0 = SVector(0.0, 0.0);\nh = SVector(0.3, 0.3);\nUgrid = DO.GridFree(u0, h);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Construction of the struct DomainList containing the quantized inputs:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Ufull = DO.DomainList(Ugrid);\nDO.add_set!(Ufull, _U_, DO.OUTER)","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Construction of the abstraction:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"symmodel = SY.NewSymbolicModelListList(Xfull, Ufull);\n@time SY.compute_symmodel_from_controlsystem!(symmodel, contsys)","category":"page"},{"location":"generated/Path planning/#Construction-of-the-controller","page":"Path planning","title":"Construction of the controller","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Computation of the initial symbolic states:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Xinit = DO.DomainList(Xgrid);\nDO.add_subset!(Xinit, Xfull, _I_, DO.OUTER)\ninitlist = [SY.get_state_by_xpos(symmodel, pos) for pos in DO.enum_pos(Xinit)];\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Computation of the target symbolic states:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Xtarget = DO.DomainList(Xgrid)\nDO.add_subset!(Xtarget, Xfull, _T_, DO.OUTER)\ntargetlist = [SY.get_state_by_xpos(symmodel, pos) for pos in DO.enum_pos(Xtarget)];\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Construction of the controller:","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"contr = CO.NewControllerList();\n@time CO.compute_controller_reach!(contr, symmodel.autom, initlist, targetlist)","category":"page"},{"location":"generated/Path planning/#Trajectory-display","page":"Path planning","title":"Trajectory display","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"We choose the number of steps nsteps for the sampled system, i.e. the total elapsed time: nstep*tstep as well as the true initial state x0 which is contained in the initial state-space _I_ defined previously.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"nstep = 100;\nx0 = SVector(0.4, 0.4, 0.0);\nnothing #hide","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"Here we display the coordinate projection on the two first components of the state space along the trajectory.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"To complete","category":"page"},{"location":"generated/Path planning/#References","page":"Path planning","title":"References","text":"","category":"section"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"G. Reissig, A. Weber and M. Rungger, \"Feedback Refinement Relations for the Synthesis of Symbolic Controllers,\" in IEEE Transactions on Automatic Control, vol. 62, no. 4, pp. 1781-1796.\nK. J. Aström and R. M. Murray, Feedback systems. Princeton University Press, Princeton, NJ, 2008.","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"","category":"page"},{"location":"generated/Path planning/","page":"Path planning","title":"Path planning","text":"This page was generated using Literate.jl.","category":"page"}]
}
